<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<nav>
    <a href="chap5.html" class="navigation previous">Anterior</a>
      <a href="chap7.html" class="navigation next">Siguiente</a>
  </nav>
<h1 id="semantics">Semántica de Tipos</h1>
<p>En la mayoría de los lenguajes de programación modernos existe el concepto de &quot;tipo&quot;. De manera informal, diremos que un tipo es una definición de especifica cuáles operaciones son válidas a realizar sobre un objeto particular. Un objeto en este caso puede ser un valor simple (<code>int</code> o <code>bool</code> en los lenguajes tipo C), o un objeto compuesto en algún lenguaje orientado a objetos. El paradigma <strong>orientado a objetos</strong> ha venido a convertirse en los últimos años en una de las columnas fundamentales del diseño y la investigación de nuevos lenguajes de programación. En este paradigma, cada &quot;valor&quot; que se puede manipulado en un programa es un <em>objeto</em>, y los objetos pueden agruparse para definir objetos más complejos. A cada objeto se le asocia un <em>tipo</em>, que define las operaciones válidas a realizar sobre dicho objeto.</p>
<p>La implementación más usual del concepto de tipo es una <strong>clase</strong>. Una clase (en C, C++, C#, Java, Python, Ruby, y tantos otros lenguajes orientados a objetos) es fundamentalmente una definición de las operaciones disponibles para un tipo. En general las clases permiten definir <em>atributos</em> que almacenan un valor, y <em>métodos</em> (o <em>funciones</em>) que permiten realizar una serie de operaciones (con o sin efectos colaterales) sobre el tipo en cuestión y los <em>argumentos</em> del método. A todos estos lenguajes los llamados <em>lenguajes tipados</em>, porque manejan el concepto de tipo. De forma general, si la operación <code>f(x)</code> (o <code>x.f()</code>) es válida en algunos contextos, e inválida en otros, aunque en ambos casos <code>f</code> y <code>x</code> son símbolos definidos, entonces diremos que dicho lenguaje es tipado, pues la validez de una operación no solo depende de que estén definidos los símbolos que participan, sino de <strong>cómo</strong> están definidos dichos símbolos. Un ejemplo de lenguaje no tipado es el lenguaje para expresiones que definimos en la sección <em>[Diseño de un AST]</em>.</p>
<p>Una forma usual de clasificar a los lenguajes tipados es la distinción entre tipado <em>dinámico</em> y <em>estático</em>. En ambos casos cada expresión, variable y método tiene asociado un tipo que define las operaciones válidas. La diferencia fundamental radica en que en los lenguajes con tipado estático, además existe una <em>declaración explícita</em> del tipo que deseamos para una expresión, variable, método, etc. Esto lo hacemos con la esperanza de poder capturar en la fase de chequeo semántico la mayor cantidad de errores asociados a inconsistencias de tipos posibles. En los lenguajes con tipado dinámico las inconsistencias de tipos no pasan desapercibidas, simplemente se espera hasta la ejecución para detectarlas.</p>
<p>En general, la discusión entre si es preferible el tipado estático o dinámico es futil. En muchas ocasiones, es conveniente tener lo antes posible una validación de que la expresión que queremos compilar no tendrá inconsistencias de tipos, y por este motivo surgieron los lenguajes con tipado estático. Por otro lado, es inevitable que existan circunstancias en las que el compilador será incapaz de inferir exactamente el tipo real que tendrá una expresión y nos impedirá realizar alguna operación cuando en realidad dicha operación sería posible. Por ejemplo, si tenemos la siguiente declaración de clases en C#:</p>
<div class="sourceCode"><pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">class</span> A {
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">F</span>() { <span class="co">/* ... */</span> }
}

<span class="kw">class</span> B : A {
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">G</span>() { <span class="co">/* ... */</span> }
}</code></pre></div>
<p>El siguiente fragmento código da error de compilación pues el tipo declarado para la variable <code>a</code> es <code>A</code>, donde no está definida la operación <code>G</code>, aunque sabemos que en caso de ejecutar, no existiría realmente ningún error de inconsistencia de tipos, pues el tipo real del objeto almancenado en <code>a</code> es <code>B</code>:</p>
<div class="sourceCode"><pre class="sourceCode cs"><code class="sourceCode cs">A a = <span class="kw">new</span> <span class="fu">B</span>();
a.<span class="fu">G</span>();</code></pre></div>
<p>Por analogía, le llamaremos <em>tipo estático</em> al tipo declarado de una variable, atributo, método, o cualquier construcción sintáctica que almacene o produzca un valor, y <em>tipo dinámico</em> al tipo asociado a dicho valor durante la ejecución del programa. Es decir, en el caso anterior, <code>a</code> es una variable con tipo estático <code>A</code>, pero que en tiempo de ejecución almacena un objeto cuyo tipo dinámico es <code>B</code>. Más adelante podremos formalizar esta noción.</p>
<p>En esta sección nos dedicaremos entonces a construir un <strong>verificador de tipos</strong>, que nos es más que un algoritmo que nos dirá si todos los usos de tipos en nuestro AST son consistentes. Idealmente, queremos que nuestro verificador de tipos nos permita decidir exactamente cuáles programas hacen un uso consistente de los tipos, pero como hemos visto en el ejemplo anterior, en ocasiones es imposible determinar exactamente cuál será el tipo dinámico de una expresión en tiempo de ejecución. En estos caso, generalmente preferimos errar por exceso, es decir, evitar la ejecución de aquellos programas donde <em>podría</em> existir una inconsistencia de tipos, aunque en la realidad no suceda. Cuando un verificador de tipos cumple esta propiedad, decimos que es <em>consistente</em>. Es decir, un verificador consistente detecta todos los programas con errores de tipo, aunque puede decidir erróneamente que un programa correcto es incorrecto. Por supuesto, queremos reducir al mínimo posible este segundo caso.</p>
<p>En los lenguajes tipados es muy común que se permita construir <em>jerarquías de tipos</em>. Estas jeraquías se construyen mediante una operación, denominada generalmente <strong>herencia</strong>, que define que un tipo <code>B</code> es un <em>subtipo</em> del tipo <code>A</code>. La semántica exacta de la herencia varía de lenguaje en lenguaje, pero en general significa que todas las operaciones definidas para <code>A</code> también lo están para <code>B</code>, aunque <code>B</code> puede introducir nuevas operaciones (métodos, atributos, etc.), o <em>sobrescribir</em> la implementación de algunas de las operaciones definidas en <code>A</code>.</p>
<p>Esta sobrescritura generalmente se asocia al nombre de <strong>polimorfismo</strong>, que para nuestro interés simplemente será el mecanismo que permite que una expresión <code>a.f()</code> se traduzca como la ejecución de una implementacion particular de <code>f</code> que depende del tipo dinámico de <code>a</code>, y no simplemente la implementación definida en el tipo estático. A este proceso le llamamos <em>resolución de métodos virtuales</em>.</p>
<p>Las reglas de la herencia varían en diversos lenguajes de programación, pero en general se distinguen dos grandes paradigmas, los lenguajes con <em>herencia simple</em>, donde cada tipo puede heredar de un solo tipo &quot;padre&quot;, y los lenguajes con herencia múltiple. En los primeros, la jerarquía de tipos es un árbol (o conjunto de árboles, si no existe un tipo base de todos los tipos), y en el segundo caso la jerarquía de tipos se comporta como un grafo dirgido y acíclico (por supuesto, la herencia cíclica es, en principio, imposible). Del mismo modo que con los lenguajes estáticos y dinámicos, existen argumentos a favor y en contra de cada paradigma, aunque de forma general, los lenguajes con herencia simple son más sencillos de verificar que los lenguajes con herencia múltiple.</p>
<p>En cualquier caso, de forma general existe una relación entre los tipos de una jerarquía, que llamaremos <strong>relación de conformidad</strong>, y denotaremos <span class="math inline"><em>B</em> ≤ <em>A</em></span>, es decir, <span class="math inline"><em>B</em></span> <em>se conforma a</em> <span class="math inline"><em>A</em></span>, si se cumple que <span class="math inline"><em>B</em></span> hereda de <span class="math inline"><em>A</em></span> o, recursivamente, si hereda de algún tipo <span class="math inline"><em>C</em></span> que se conforme a <span class="math inline"><em>A</em></span>. Verificar esta relación de conformidad en una implementación concreta de un verificador de tipos implica recorrer el árbol o grafo de la jerarquía de tipos. De momento asumiremos la relación como dada, y más adelante veremos ideas para su implementación en un ejemplo concreto.</p>
<h2 id="verificando-tipos">Verificando tipos</h2>
<p>De modo que el problema que tenemos que resolver es, para un nodo particular del AST, si el uso de los tipos es consistente. Este proceso en general lo haremos <em>bottom-up</em>, ya que la consistencia del uso de tipos en una expresión particular dependerá de los tipos en sus partes componentes. Por lo tanto, en un recorrido en post-orden del AST, iremos computando los tipos asociados a los nodos &quot;hijos&quot;, y en el retorno chequearemos en cada &quot;padre&quot; la consistencia y computaremos el tipo del padre. Por ejemplo, si estamos en un nodo <code>SumExpr</code> que representa una expresión binaria de suma, podemos decir que este nodo es consistente si y solo sí cada una de las expresiones son a su vez consistentes, y son de tipo <code>int</code>, y la expresión en general es de tipo <code>int</code> también:</p>
<div class="sourceCode"><pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">class</span> SumExpr : Expression {
    <span class="kw">public</span> Expression Left;
    <span class="kw">public</span> Expression Right;
    <span class="kw">public</span> Type NodeType;

    <span class="kw">public</span> <span class="dt">bool</span> <span class="fu">CheckTypes</span>() {
        <span class="kw">if</span> (!Left.<span class="fu">CheckTypes</span>() || !Right.<span class="fu">CheckTypes</span>()) {
            <span class="kw">return</span> <span class="kw">false</span>;
        }

        <span class="kw">if</span> (Left.<span class="fu">NodeType</span> != Type.<span class="fu">Integer</span> ||
            Right.<span class="fu">NodeType</span> != Type.<span class="fu">Integer</span>) {
            <span class="kw">return</span> <span class="kw">false</span>;
        }

        NodeType = Type.<span class="fu">Integer</span>;
        <span class="kw">return</span> <span class="kw">true</span>;
    }
}</code></pre></div>
<p>De este modo, recursivamente, podemos computar el tipo de todas las expresiones de un lenguaje (todos los posibles nodos de un AST). Vamos a definir a continuación una notación formal para expresar esta noción del chequeo de tipos de forma recursiva. La notación que definiremos tiene la forma de una demostración en el lenguaje de la lógica de predicados. Comienza con una lista de precondiciones lógicas (sobre los tipos de las sub-expresiones), y termina con una conclusión que dice cuál es el tipo de la expresión actual. Por ejemplo, para el caso anterior, podemos escribir:</p>
<p><br /><span class="math display">$$
\begin{array}{l}
e_1 : Integer \\
e_2 : Integer \\
\hline
\vdash e_1 + e_2 : Integer
\end{array}
$$</span><br /></p>
<p>Podemos leer esta expresión de la siguiente forma: si <span class="math inline"><em>e</em><sub>1</sub></span> es una expresión de tipo <span class="math inline"><em>I</em><em>n</em><em>t</em><em>e</em><em>g</em><em>e</em><em>r</em></span> y <span class="math inline"><em>e</em><sub>2</sub></span> es una expresión de tipo <span class="math inline"><em>I</em><em>n</em><em>t</em><em>e</em><em>g</em><em>e</em><em>r</em></span>, entonces se deduce que la expresión <span class="math inline"><em>e</em><sub>1</sub> + <em>e</em><sub>2</sub></span> es de tipo <span class="math inline"><em>I</em><em>n</em><em>t</em><em>e</em><em>g</em><em>e</em><em>r</em></span>. El símbolo <span class="math inline">⊢</span> significa &quot;se deduce que&quot;.</p>
<h2 id="contextos">Contextos</h2>
<p>Una pregunta interesante es ¿qué sucede con las variables? Dado que estamos en un recorrido <em>bottom-up</em>, nos encontraremos la declaración de una variable luego de su uso. Luego, si nos encontramos un nodo <code>VarExpr</code> que representa el uso de una variable, ¿qué tipo le asociamos? En la sección <em>[Validando las reglas semánticas]</em> introdujimos el concepto de <em>contexto</em>, para almacenar las declaraciones anteriores, de forma que siempre supiéramos qué símbolo estaba declarado en cualquier expresión. Ahora vamos a extender este contexto, para especificar no solo los símbolos declarados, sino qué tipo está asociado a cada símbolo. Vamos a introducir entonces una función <span class="math inline"><em>O</em></span> que llamaremos <em>contexto de objetos</em>, y que usaremos de la forma <span class="math inline"><em>O</em>(<em>x</em>)=<em>T</em></span> para decir que este nodo existe un símbolo <span class="math inline"><em>x</em></span> definido con tipo estático declarado <span class="math inline"><em>T</em></span>. Por tanto, extenderemos nuestra notación para incluir el contexto de objetos como parte de las precondiciones y la conclusión. Luego, la expresión suma quedaría de la forma:</p>
<p><br /><span class="math display">$$
\begin{array}{l}
O \vdash e_1 : Integer \\
O \vdash e_2 : Integer \\
\hline
O \vdash e_1 + e_2 : Integer
\end{array}
$$</span><br /></p>
<p>Que podemos leer de la siguiente forma: si dado el contexto de objetos <span class="math inline"><em>O</em></span>, podemos deducir (recursivamente) que el tipo de <span class="math inline"><em>e</em><sub>1</sub></span> es <span class="math inline"><em>I</em><em>n</em><em>t</em><em>e</em><em>g</em><em>e</em><em>r</em></span> (e igual para <span class="math inline"><em>e</em><sub>2</sub></span>), entonces en este mismo contexto de objetos podemos deducir que el tipo de <span class="math inline"><em>e</em><sub>1</sub> + <em>e</em><sub>2</sub></span> es <span class="math inline"><em>I</em><em>n</em><em>t</em><em>e</em><em>g</em><em>e</em><em>r</em></span>. Es importante notar que hemos dicho <span class="math inline"><em>O</em> ⊢ <em>e</em> : <em>T</em></span>, y no <span class="math inline"><em>O</em>(<em>e</em>)=<em>T</em></span>, pues <span class="math inline"><em>e</em></span> es una expresión en el sentido general, y <span class="math inline"><em>O</em></span> solamente está definido para símbolos (variables, atributos, etc.). Por tanto, <span class="math inline"><em>O</em> ⊢ <em>e</em> : <em>T</em></span> nos indica que es necesario chequear el tipo de <span class="math inline"><em>e</em></span> recursivamente en el contexto <span class="math inline"><em>O</em></span> para computar el tipo que tiene la expresión.</p>
<p>Los contextos de objetos se modifican cuando aparecen expresiones (instrucciones) que introducen nuevos símbolos (e.g. declaraciones de variables). Supongamos entonces que tenemos una expresión de la forma <span class="math inline">$T x \is e$</span>, que indica que la variable <span class="math inline"><em>x</em></span> se define con el tipo <span class="math inline"><em>T</em></span> y se inicializa con la expresión <span class="math inline"><em>e</em></span>. Este es el tipo de instrucción que comunmente vemos en lenguajes tipo C para inicializar una variable recién declarada:</p>
<div class="sourceCode"><pre class="sourceCode cs"><code class="sourceCode cs"><span class="dt">int</span> x = <span class="dv">4</span> + <span class="dt">int</span>.<span class="fu">Parse</span>(Console.<span class="fu">ReadLine</span>());</code></pre></div>
<p>En esta instrucción se introduce un nuevo símbolo en el contexto de objetos, con el nombre <span class="math inline"><em>x</em></span>, y el tipo <span class="math inline"><em>T</em></span>. Luego, es necesario verificar que el tipo de la expresión <span class="math inline"><em>e</em></span> se conforme al tipo <span class="math inline"><em>T</em></span>, y luego definir el tipo de retorno de toda la expresión. En el caso particular de C, una instrucción de tipo asignación como esta no puede ser usada como expresión, y por tanto no devuelve valor, así que usaremos el símbolo <span class="math inline">∅</span> para especificar que no tiene asociado (equivalente a <code>void</code>). Para especificar la modificación del contexto de objetos, introduciremos la sintaxis <span class="math inline"><em>O</em>[<em>T</em>/<em>x</em>]</span> que significa, informalmente, un nuevo contexto de objetos con las mismas definiciones que tenía <span class="math inline"><em>O</em></span>, pero además adicionando la definición del símbolo <span class="math inline"><em>x</em></span> con tipo <span class="math inline"><em>T</em></span>. Formalmente:</p>
<p><br /><span class="math display">$$
O[T/x](c) = \left\{ \begin{array}{ll} T &amp; c = x \\ O(c) &amp; c \neq x \end{array} \right.
$$</span><br /></p>
<p>Armados con esta nueva notación, podemos definir la semántica de un nodo de declaración e inicialización:</p>
<p><br /><span class="math display">$$
\begin{array}{l}
O \vdash e : T' \\
T' \leq T \\
\hline
O[T/x] \vdash T x \is e : \emptyset
\end{array}
$$</span><br /></p>
<p>Podemos leer esta definición de la siguiente forma: si en el contexto actual el tipo de la expresión <span class="math inline"><em>e</em></span> es <span class="math inline"><em>T</em>′</span>, y <span class="math inline"><em>T</em>′</span> conforma a <span class="math inline"><em>T</em></span>, entonces en un nuevo contexto definimos <span class="math inline"><em>x</em></span> con tipo <span class="math inline"><em>T</em></span>, y el tipo de retorno de la expresión es <code>void</code>.</p>
<p>El otro problema de interés es cuando nos encontramos con la declaración o invocación de un método. De forma general, vamos a considerar que es permitido sobrescribir la implementación de un método <span class="math inline"><em>A</em>.<em>f</em></span> en una clase <span class="math inline"><em>B</em> ≤ <em>A</em></span>, siempre y cuando el tipo declarado de los parámetros de <span class="math inline"><em>f</em></span> y el tipo de retorno de <span class="math inline"><em>f</em></span> no cambien. Esto es lo que sucede en la mayoría de los lenguajes de tipado estático. En este caso, desde el punto de vista del chequeo de tipos, no nos interesa realmente cuál es la implementación concreta de <span class="math inline"><em>f</em></span>, ya que todas las implementaciones coinciden en cuanto a las definiciones de tipos.</p>
<p>Vamos a introducir entonces un nuevo tipo de contexto <span class="math inline"><em>M</em></span>, que llamaremos <em>contexto de métodos</em>, y que usaremos de la forma <span class="math inline"><em>M</em>(<em>T</em>, <em>f</em>)={<em>T</em><sub>1</sub>,…,<em>T</em><sub><em>n</em> + 1</sub>}</span>, para expresar que el método <span class="math inline"><em>f</em></span> definido en el tipo <span class="math inline"><em>T</em></span> (o definido en algún tipo <span class="math inline"><em>T</em>′</span> tal que <span class="math inline"><em>T</em> ≤ <em>T</em>′</span>), tiene <span class="math inline"><em>n</em></span> argumentos de tipo <span class="math inline"><em>T</em><sub>1</sub>, …, <em>T</em><sub><em>n</em></sub></span>, y tipo de retorno <span class="math inline"><em>T</em><sub><em>n</em> + 1</sub></span>. El contexto <span class="math inline"><em>M</em></span> no se modifica, sino que se construye en un primer recorrido por el AST, y luego simplememente sirve para consultar. De modo que asumiremos que en todo momento durante el chequeo de tipos, ya son conocidos de antemano todos los métodos declarados en todos los tipos accesibles por el programa que está siendo compilado.</p>
<p>Tenemos entonces dos tipos de expresiones interesantes, la <em>declaración</em> de un método, y la <em>invocación</em>. Comenzaremos por la invocación de un método de instancia. Supongamos una sintaxis de la forma <span class="math inline"><em>x</em> ⋅ <em>f</em>(<em>e</em><sub>1</sub>, …, <em>e</em><sub><em>n</em></sub>)</span> para la invocación de métodos. Tenemos entonces que verificar el tipo de la expresión <span class="math inline"><em>x</em></span>, obtener el método <span class="math inline"><em>f</em></span> asociado a ese tipo, verificar la conformación de los tipos de los argumentos, y entonces podemos computar el tipo de <span class="math inline"><em>f</em></span>:</p>
<p><br /><span class="math display">$$
\begin{array}{l}
O \vdash x : T \\
M(T,f) = \left\{ T_1, \ldots, T_{n+1} \right\} \\
O \vdash e_i : T_i' \,\,\, \forall i = 1 \ldots n \\
T_i' \leq T \,\,\, \forall i = 1 \ldots n \\
\hline
O,M \vdash x \cdot f(e_1, \ldots, e_n) : T_{n+1}
\end{array}
$$</span><br /></p>
<p>La invocación de un método estático es muy similar. Supongamos una sintaxis de la forma <span class="math inline"><em>T</em> ⋅ <em>f</em>(<em>e</em><sub>1</sub>, …, <em>e</em><sub><em>n</em></sub>)</span>, la diferencia fundamental es que no es necesario computar el tipo de la expresión a quién se le invoca el método, pues la clase está definida explícitamente. Todo lo demás es prácticamente idéntico.</p>
<p><br /><span class="math display">$$
\begin{array}{l}
M(T,f) = \left\{ T_1, \ldots, T_{n+1} \right\} \\
O \vdash e_i : T_i' \,\,\, \forall i = 1 \ldots n \\
T_i' \leq T \,\,\, \forall i = 1 \ldots n \\
\hline
O,M \vdash T \cdot f(e_1, \ldots, e_n) : T_{n+1}
\end{array}
$$</span><br /></p>
<p>Para poder formalizar la declaración de métodos, tenemos que introducir un nuevo elemento en nuestra notación, que llamaremos <span class="math inline"><em>C</em></span>, y que representará la <em>clase</em> actual donde se está realizando la verificación de la expresión correspondiente. En los lenguajes sin orientación a objetos (C) o donde no todo el código reside dentro de una clase (C++, Python), podemos definir un tipo especial <span class="math inline"><em>Ω</em></span> que representa el contexto &quot;global&quot;. En última instancia, lo que queremos es poder diferenciar un método <span class="math inline"><em>f</em></span> de otro del mismo nombre pero definido en un contexto diferente. Las clases son una de las posibles formas de definir un contexto, pero nada nos impide extender esta noción e incluir un contexto global. En algunos lenguajes se le llama <em>espacio de nombres</em> o <strong>namespace</strong> a un contexto donde todos los símbolos son de nombre distinto. En Python, por ejemplo, cada módulo define un nuevo espacio de nombres, donde los símbolos definidos ocultan, pero no sobrescriben a los símbolos definidos en otro módulo.</p>
<p>Por otro lado, vamos a extender el concepto de contexto de objetos, para especificar <span class="math inline"><em>O</em><sub><em>C</em></sub></span> como el contexto específico dentro de la clase <span class="math inline"><em>C</em></span>. Es decir, en este contexto daremos por supuesto que ya están definidos todos los atributos y métodos de <span class="math inline"><em>C</em></span>, que son visibles dentro del cuerpo de cada función. Por ejemplo, en C# serían todos los campos declarados en <span class="math inline"><em>C</em></span> o declarados en algún padre de <span class="math inline"><em>C</em></span> con la visibilidad adecuada (no <code>private</code>).</p>
<p>Podemos entonces presentar una formalización de la semántica de tipos la definición de métodos. Supongamos una sintaxis de la forma:</p>
<p><br /><span class="math display"><em>f</em>(<em>x</em><sub>1</sub> : <em>T</em><sub>1</sub>, …, <em>x</em><sub><em>n</em></sub> : <em>T</em><sub><em>n</em></sub>):<em>T</em>{<em>e</em>}</span><br /></p>
<p>Donde <span class="math inline"><em>x</em><sub><em>i</em></sub> : <em>T</em><sub><em>i</em></sub></span> representa un argumento de <span class="math inline"><em>f</em></span> de nombre <span class="math inline"><em>x</em><sub><em>i</em></sub></span> y tipo <span class="math inline"><em>T</em><sub><em>i</em></sub></span>, <span class="math inline"><em>T</em></span> es el tipo de retorno, y <span class="math inline"><em>e</em></span> representa el cuerpo del método (visto como una expresión para simplificar).</p>
<p>A grandes razgos el proceso es el siguiente: se definen los argumentos <span class="math inline"><em>x</em><sub><em>i</em></sub></span> en el contexto de objetos hijo de <span class="math inline"><em>O</em><sub><em>C</em></sub></span> donde se va a verificar la expresión <span class="math inline"><em>e</em></span> y se verifica que el tipo del cuerpo conforme al tipo declarado de la función. Un tratamiento especial es necesario para el valor asociado a la instancia actual, que generalmente se llama <code>this</code> (C#) o <code>self</code> (Python). Por definición este símbolo en la instancia donde se está definiendo el método tiene exactamente el tipo <span class="math inline"><em>C</em></span>:</p>
<p><br /><span class="math display">$$
\begin{array}{l}
M(C,f) = \{ T_1, \ldots, T_n, T \} \\
O_C[T_1/x_1,\ldots,T_n/x_n,C/self] \vdash e : T' \\
T' \leq T \\
\hline
O_C,M,C \vdash f(x_1 : T_1, \ldots, x_n : T_n) : T \{ e \}
\end{array}
$$</span><br /></p>
<p>Existen disímiles expresiones con reglas de tipos diversas pero, a grandes razgos, hemos mostrado cómo luce la formalización de la semántica de tipos de una expresión arbitraria. Armados con los conceptos de contexto de objetos y métodos, y una definición formal de la semántica de tipos para un lenguaje concreto de ejemplo, ya estamos en condiciones de implementar un verificador de tipos.</p>
<h2 id="implementando-un-verificador-de-tipos">Implementando un verificador de tipos</h2>
<p>Para implementar un verificador de tipos necesitamos concretar dos elementos: una clase que nos permita manejar el contexto de objetos y el contexto de métodos, y un algoritmo para recorrer el AST. Vamos a ejemplificar algunos detalles de implementación, asumiendo un lenguaje orientado a objetos muy simple, con las siguientes características:</p>
<ul>
<li>Un programa consiste en una lista de definiciones de clases.</li>
<li>Todas las clases se definen en el mismo espacio de nombres global.</li>
<li>Cada clase tiene atributos y métodos.</li>
<li>Los atributos tienen un tipo asociado.</li>
<li>Los métodos tienen un tipo de retorno (que puede ser <code>void</code>), y una lista de argumentos.</li>
<li>Todos los atributos son privados y todos los métodos son publicos.</li>
<li>Existe herencia simple.</li>
<li>Un método se puede sobrescribir sí y solo sí se mantiene exactamente la misma definición para los tipos de retorno y de los argumentos.</li>
<li>No existen sobrecargas de métodos ni de operadores.</li>
<li>El cuerpo de todo método es una expresión.</li>
</ul>
<p>No vamos a especificar formalmente qué tipos de expresiones son válidas en este lenguaje, pero de forma general podemos pensar en ciclos, condicionales, expresiones aritméticas, inicializaciones (<code>new T()</code>), invocaciones a métodos, etc. En fin, todos los tipos de expresiones comunes en un lenguaje orientado a objetos moderno. Solamente formalizaremos algunas de estas expresiones cuando nos interese mostrar la implementación.</p>
<p>Comencemos por representar los conceptos de tipo, atributo y método:</p>
<div class="sourceCode"><pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">interface</span> IType {
    <span class="dt">string</span> Name { <span class="kw">get</span>; }
    IAtribute[] Attributes { <span class="kw">get</span>; }
    IMethod[] Methods { <span class="kw">get</span>; }
    IAttribute <span class="fu">GetAttribute</span>(<span class="dt">string</span> name);
    IMethod <span class="fu">GetMethod</span>(<span class="dt">string</span> name);
    <span class="dt">bool</span> <span class="fu">DefineAttribute</span>(<span class="dt">string</span> name, IType type);
    <span class="dt">bool</span> <span class="fu">DefineMethod</span>(<span class="dt">string</span> name, IType returnType,
                      <span class="dt">string</span>[] arguments, IType[] argumentTypes);
}

<span class="kw">interface</span> IAttribute {
    <span class="dt">string</span> Name { <span class="kw">get</span>; }
    IType Type { <span class="kw">get</span>; }
}

<span class="kw">interface</span> IMethod {
    <span class="dt">string</span> Name { <span class="kw">get</span>; }
    IType ReturnType { <span class="kw">get</span>; }
    IAttribute[] Arguments { <span class="kw">get</span>; }
}</code></pre></div>
<p>Para representar un contexto podemos usar la siguiente <em>interface</em>, similar al contexto que hemos usado anteriormente en la sección <em>[Validando las reglas semánticas]</em>, pero modificada para adaptarse las definiciones anteriores:</p>
<div class="sourceCode"><pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">interface</span> IContext {
    IType <span class="fu">GetType</span>(<span class="dt">string</span> typeName);
    IType <span class="fu">GetTypeFor</span>(<span class="dt">string</span> symbol);
    IContext <span class="fu">CreateChildContext</span>();
    <span class="dt">bool</span> <span class="fu">DefineSymbol</span>(<span class="dt">string</span> symbol, IType type);
    IType <span class="fu">CreateType</span>(<span class="dt">string</span> name)
}</code></pre></div>
<p>Esta <em>interface</em> básicamente nos representa el contexto de objetos. El contexto de métodos realmente lo tenemos modelado como parte de la definición de cada tipo, por lo que no es necesario tener un contexto de métodos global. El propio tipo <span class="math inline"><em>C</em></span> nos permitirá acceder al contexto de métodos del tipo actual. Por otro lado, para acceder al contexto de métodos de un tipo específico, basta resolver la instancia de <code>IType</code> correspondiente (mediante el método <code>GetType</code>).</p>
<p>Vamos a definir entonces un subconjunto de los nodos del AST que nos interesa modelar. Comenzaremos como siempre por una clase base:</p>
<div class="sourceCode"><pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">abstract</span> <span class="kw">class</span> Node {

}</code></pre></div>
<p>Nuestro siguiente nodo es un programa, que se compone de una lista de definiciones de clase:</p>
<div class="sourceCode"><pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">class</span> Program : Node {
    <span class="kw">public</span> List&lt;ClassDef&gt; Classes;
}</code></pre></div>
<p>Cada definición de clase a su vez define un tipo con un nombre y una lista de atributos y métodos:</p>
<div class="sourceCode"><pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">class</span> ClassDef : Node {
    <span class="kw">public</span> <span class="dt">string</span> Name;
    <span class="kw">public</span> List&lt;AttrDef&gt; Attributes;
    <span class="kw">public</span> List&lt;MethodDef&gt; Methods;
}</code></pre></div>
<p>Los atributos se definen como un nombre, tipo asociado, y una expresión de inicialización:</p>
<div class="sourceCode"><pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">class</span> AttrDef : Node {
    <span class="kw">public</span> <span class="dt">string</span> Name;
    <span class="kw">public</span> <span class="dt">string</span> Type;
    <span class="kw">public</span> Expression Initialization;
}</code></pre></div>
<p>Mientras que los métodos se definen como un nombre, una lista de argumentos (nombres y tipos), un tipo de retorno, y un cuerpo que es una expresión:</p>
<div class="sourceCode"><pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">class</span> MethodDef : Node {
    <span class="kw">public</span> <span class="dt">string</span> Name;
    <span class="kw">public</span> <span class="dt">string</span> ReturnType;
    <span class="kw">public</span> List&lt;<span class="dt">string</span>&gt; ArgNames;
    <span class="kw">public</span> List&lt;<span class="dt">string</span>&gt; ArgTypes;
    <span class="kw">public</span> <span class="dt">string</span> ReturnType;
    <span class="kw">public</span> Expression Body;
}</code></pre></div>
<p>Luego nos quedarían todos los nodos de la jerarquía de expresiones, que no mostraremos por simplicidad.</p>
<p>Centraremos a continuación nuestra atención en el problema de la verificación en sí. De forma general, primero tenemos que hacer un recorrido por todo el AST para encontrar todas las definiciones de tipos. Este primer paso es necesario antes de verificar los métodos o atributos de un tipo particular, ya que podemos tener una declaración de un tipo <code>A</code> con un atributo de tipo <code>B</code>, donde la declaración del tipo <code>B</code> aparece luego de la declaración de <code>A</code>. Por este motivo, es necesario recolectar primero todos los nombres de todas las clases declaradas y adicionarlos al contexto. Luego es necesario volver a recorrer todo el AST pero esta vez recogiendo las declaraciones de métodos y atributos, a quienes ya podemos asociar los tipos correspondientes. Esta segunda vez también es necesaria antes de pasar a analizar el cuerpo de los métodos, pues podemos tener un método <code>F</code> llamando a otro método <code>G</code> que está definido posteriormente. De esta forma completamos el contexto de métodos, y podemos finalmente recorrer el AST una vez más, esta vez adentrándonos en el cuerpo de los métodos y verificando la semántica de las expresiones.</p>
<p>De modo que necesitamos hacer al menos 3 pasadas por el AST, ya que podemos tener definiciones que usen a su vez símbolos definidos posteriormente. Para evitar esto, en lenguajes como C y C++ es necesario declarar de antemano en archivo <em>header</em> (con extensión <code>.h</code>) los símbolos que luego serán definidos (en un archivo <code>.c</code>).</p>
<p>Una primera aproximación a este problema nos lleva a definir al menos 3 métodos recursivos, uno para buscar las definiciones de tipos, otro para los métodos y atributos, y otro finalmente para la semántica. A medida que nuestro lenguaje crece, la semántica se complica, y aparecen nuevas fases (como la generación de código que veremos más adelante), notaremos que se repite este patrón de recorrer todo el AST buscando algunos nodos particulares y haciendo algunas operaciones en ellos. Por lo tanto, esta solución de definir un método recursivo para cada posible recorrido por el AST se vuelve cada vez menos atractivo. Cada vez que adicionamos algún tipo de chequeo tendremos que modificar la jerarquía del AST para acomodar los métodos recursivos necesarios. Por otro lado, si decidimos introducir un tipo de nodo nuevo (porque nuestra gramática ha cambiado o porque es conveniente especializar alguna función semántica), tendremos que redefinir todos estos métodos de chequeo en consecuencia. Por último, la mayoría de estos métodos recursivos se van a parecer mucho, pues todos tienen que descender recursivamente por los nodos del AST, y realizar alguna operación en pre-orden o post-orden.</p>
<p>El problema que tenemos aquí es un caso típico de acoplamiento, que nos lleva a una replicación de comportamiento similar. Tenemos que reconocer que existen dos responsabilidades diferentes en cada uno de estos casos: una es la que juega cada nodo del AST, que consiste en representar la función semántica correspondiente; y la otra es justamente el procesamiento necesario a realizar en un nodo para verificar algún predicado semántico. Vamos entonces a separar la responsabilidad de procesar a un nodo del nodo en sí, y ponerla en una clase distinta. A este diseño que presentaremos se le denomina el <strong>patrón visitor</strong>, y es uno de los patrones de diseño más populares y útiles, especialmente en la implementación de compiladores.</p>
<h2 id="el-patrón-visitor">El Patrón Visitor</h2>
<p>Comenzaremos por definir la siguiente <em>interface</em>:</p>
<div class="sourceCode"><pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">interface</span> IVisitor&lt;TNode&gt; where TNode : Node {
    <span class="dt">void</span> <span class="fu">Visit</span>(TNode node);
}</code></pre></div>
<p>La <em>interface</em> <code>IVisitor&lt;TNode&gt;</code> nos permitirá abstraer el concepto de procesamiento sobre un nodo. En cada implementación particular, escogeremos qué procesamiento realizar sobre cada tipo de nodo particular, y cómo &quot;caminar&quot; sobre la porción de AST correspondiente. Veamos entonces como implementar la primera pasada, que nos permite recolectar todos los tipos definidos. Este <em>visitor</em> solamente se interesa en nodos de tipo <code>Program</code> y nodos de tipo <code>ClassDef</code>. Su tarea consiste en crear un contexto, y definir en este contexto todos los tipos que se encuentre:</p>
<div class="sourceCode"><pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">class</span> TypeCollectorVisitor: IVisitor&lt;Program&gt;,
                                   IVisitor&lt;ClassDef&gt; {
    <span class="kw">public</span> IContext Context;

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">Visit</span>(Program node) {
        Context = <span class="kw">new</span> <span class="co">// ...</span>

        <span class="kw">foreach</span>(var classDef <span class="kw">in</span> node.<span class="fu">Classes</span>) {
            <span class="kw">this</span>.<span class="fu">Visit</span>(classDef);
        }
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">Visit</span>(ClassDef node) {
        Context.<span class="fu">CreateType</span>(node.<span class="fu">Name</span>);
    }
}</code></pre></div>
<p>El llamado <code>this.Visit(classDef)</code> resolverá estáticamente la sobrecarga adecuada. Veamos ahora como implementar un <em>visitor</em> que construya todo el contexto de métodos y atributos. En este caso, nos interesan además los nodos de tipo <code>AttrDef</code> y <code>MethodDef</code>:</p>
<div class="sourceCode"><pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">class</span> TypeBuilderVisitor : IVisitor&lt;Program&gt;,
                                  IVisitor&lt;ClassDef&gt;,
                                  IVisitor&lt;AttrDef&gt;,
                                  IVisitor&lt;MethodDef&gt; {

    <span class="kw">public</span> IContext Context;
    <span class="kw">private</span> IType currentType;

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">Visit</span>(Program node) {
        <span class="kw">foreach</span>(var classDef <span class="kw">in</span> node.<span class="fu">Classes</span>) {
            <span class="kw">this</span>.<span class="fu">Visit</span>(classDef);
        }
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">Visit</span>(ClassDef node) {
        currentType = Context.<span class="fu">GetType</span>(node.<span class="fu">Name</span>);

        <span class="kw">foreach</span>(var attrDef <span class="kw">in</span> node.<span class="fu">Attributes</span>) {
            <span class="kw">this</span>.<span class="fu">Visit</span>(attrDef);
        }

        <span class="kw">foreach</span>(var methodDef <span class="kw">in</span> node.<span class="fu">Methods</span>) {
            <span class="kw">this</span>.<span class="fu">Visit</span>(methodDef);
        }
    }

    <span class="co">// ...</span>
}</code></pre></div>
<p>Hasta este punto simplemente hemos descendido por las definiciones de tipos hasta llegar a cada definición de atributo o método. En cada paso, nos hemos asegurado además de mantener una referencia al tipo concreto dentro del cual se están realizando las definiciones. Veamos entonces los métodos restantes:</p>
<div class="sourceCode"><pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">class</span> TypeBuilderVisitor : IVisitor&lt;Program&gt;,
                                  IVisitor&lt;ClassDef&gt;,
                                  IVisitor&lt;AttrDef&gt;,
                                  IVisitor&lt;MethodDef&gt; {

    <span class="kw">public</span> IContext Context;
    <span class="kw">private</span> IType currentType;

    <span class="co">// ...</span>

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">Visit</span>(AttrDef node) {
        IType attrType = Context.<span class="fu">GetType</span>(node.<span class="fu">Type</span>);
        currentType.<span class="fu">DefineAttribute</span>(node.<span class="fu">Name</span>, attrType);
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">Visit</span>(MethodDef node) {
        IType returnType = Context.<span class="fu">GetType</span>(node.<span class="fu">ReturnType</span>);
        <span class="dt">var</span> argTypes = node.<span class="fu">ArgTypes</span>.<span class="fu">Select</span>(t =&gt; Context.<span class="fu">GetType</span>(t));

        currentType.<span class="fu">DefineMethod</span>(node.<span class="fu">Name</span>, returnType,
                                 node.<span class="fu">ArgNames</span>.<span class="fu">ToArray</span>(),
                                 argTypes.<span class="fu">ToArray</span>());
    }
}</code></pre></div>
<p>Por último, tendremos un <code>TypeCheckerVisitor</code> que verificará finalmente la consistencia de tipos en todos los nodos del AST. Este implementará la <em>interface</em> <code>IVisitor&lt;T&gt;</code> en cada tipo de nodo que sea capaz de chequear, incluidos todos los tipos de expresiones e instrucciones que no hemos definido. A este <code>TypeCheckerVisitor</code> le pasaremos el contexto ya construido anteriormente, y lo dejaremos procesar todo el AST. Este <em>visitor</em> además de verificar el tipo de todas las expresiones, será el encargado de computar el tipo asociado a cada expresión y almacenarlo en el nodo <code>Expression</code>:</p>
<div class="sourceCode"><pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">abstract</span> <span class="kw">class</span> Expression {
    <span class="kw">public</span> IType ComputedType;
}</code></pre></div>
<p>Hemos obviado hasta el momento cualquier consideración de error. Si alguno de los tipos definidos para alguno de los atributos o métodos no es válido, o alguno de los tipos aparece declarado más de una vez, o cualquier otro error semántico es detectado, nuestro verificador lanzará una excepción, o peor, fallará silenciosamente. Para manejar los errores de forma consistente, adicionaremos a los métodos <code>Visit</code> un argumento <code>IErrorLogger</code> con la <em>interface</em> siguiente:</p>
<div class="sourceCode"><pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">interface</span> IErrorLogger {
    <span class="dt">void</span> <span class="fu">LogError</span>(<span class="dt">string</span> msg);
}</code></pre></div>
<p>De modo que ante un error cualquier de chequeo de tipos, simplemente nos remitiremos a este objeto para indicar que ocurrió un error. Una vez detectado el error, la pregunta que queda es ¿qué hacer a continuación? Si detenemos el chequeo entonces nuestro compilador solamente será capaz de detectar un error en cada iteración, pero idealmente quisiéramos indicar la mayor cantidad de errores posibles en cada corrida. Por lo tanto, lo que se sugiere es tomar alguna acción de reparo sensata y continuar la verificacion. Por ejemplo:</p>
<div class="sourceCode"><pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">class</span> TypeCheckerVisitor : IVisitor&lt;...&gt; {
    <span class="kw">public</span> Context Context;

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">Visit</span>(BinaryExpr node, IErrorLogger logger) {
        <span class="kw">this</span>.<span class="fu">Visit</span>(node.<span class="fu">Left</span>, logger);
        <span class="kw">this</span>.<span class="fu">Visit</span>(node.<span class="fu">Right</span>, logger);

        <span class="kw">if</span> (node.<span class="fu">Left</span>.<span class="fu">ComputedType</span> != node.<span class="fu">Right</span>.<span class="fu">ComputedType</span>) {
            logger.<span class="fu">LogError</span>(<span class="st">&quot;Type mismatch...&quot;</span>);
            node.<span class="fu">ComputedType</span> = <span class="kw">null</span>;
        }
        <span class="kw">else</span> {
            node.<span class="fu">ComputedType</span> = node.<span class="fu">Left</span>.<span class="fu">ComputedType</span>;
        }
    }
}</code></pre></div>
<p>Con estas herramientas, podemos adicionar un método en la clase <code>Program</code> que realice todas las pasadas correspondientes:</p>
<div class="sourceCode"><pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">class</span> Program : Node {
    <span class="co">// ...</span>

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">CheckSemantics</span>(IErrorLogger logger) {
        <span class="dt">var</span> typeCollector = <span class="kw">new</span> <span class="fu">TypeCollectorVisitor</span>();
        typeCollector.<span class="fu">Visit</span>(<span class="kw">this</span>, logger);

        <span class="dt">var</span> typeBuilder = <span class="kw">new</span> <span class="fu">TypeBuilderVisitor</span>() {
            Context = typeCollector.<span class="fu">Context</span>
        };

        typeBuilder.<span class="fu">Visit</span>(<span class="kw">this</span>, logger);

        <span class="dt">var</span> typeChecker = <span class="kw">new</span> <span class="fu">TypeCheckerVisitor</span>() {
            Context = typeBuilder.<span class="fu">Context</span>;
        };

        typeChecker.<span class="fu">Visit</span>(<span class="kw">this</span>, logger);
    }
}</code></pre></div>
<nav>
    <a href="chap5.html" class="navigation previous">Anterior</a>
      <a href="chap7.html" class="navigation next">Siguiente</a>
  </nav>
</body>
</html>
