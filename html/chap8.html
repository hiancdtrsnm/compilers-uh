<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<nav>
    <a href="chap7.html" class="navigation previous">Anterior</a>
    </nav>
<h1 id="el-lenguaje-hulk">El lenguaje HULK</h1>
<p>En este capítulo definimos el lenguaje <strong>HULK</strong> (<em>Havana University Language for Kompilers</em>), un lenguaje de programación didáctico diseñado para este curso. A grandes razgos, <strong>HULK</strong> es un lenguaje orientado a objetos, con herencia simple, polimorfismo, y encapsulamiento a nivel de clases. Además en <strong>HULK</strong> es posible definir funciones globales fuera del contexto de cualquier clase. También es posible definir <em>una única expresión global</em> que constituye el punto de entrada al programa.</p>
<p>La mayoría de las construcciones sintácticas en <strong>HULK</strong> son expresiones, incluyendo las instrucciones condicionales y los ciclos. <strong>HULK</strong> es un lenguaje estáticamente tipado con inferencia de tipos, lo que significa que algunas (o todas) las partes de un programa pueden ser anotadas con tipos, y el compilador verificará la consistencia de todas las operaciones.</p>
<p>El lenguaje <strong>HULK</strong> ha sido diseñado para ser utilizado como mecanismo de aprendizaje y evaluación de un curso de Compilación. Por tal motivo, ciertas decisiones de diseño de lenguaje responden más a cuestiones didácticas que a cuestiones teóricas o pragmáticas. Un ejemplo ilustrativo es la inclusión de un solo tipo numérico básico. En la práctica los lenguajes de programación cuentan con varios tipos numéricos (<code>int</code>, <code>float</code>, <code>double</code>, <code>decimal</code>) para cubrir el amplio rango de <em>trade-off</em> entre eficiencia y expresividad. Sin embargo, desde el punto de vista didáctico, ya es suficiente complejidad el tener que lidiar con un tipo numérico, y la inclusión de otros no aporta nada nuevo desde nuestro punto de vista.</p>
<p>Otra decisión importante es el tipado estático con inferencia de tipos, que será explicado más adelante en detalle. La motivación detrás de esta característica es permitir a los estudiantes implementar primero un evaluador para el lenguaje, y luego preocuparse por la verificación de tipos. Así mismo, la decisión de tener expresiones globales, funciones globales, y clases, responde a la necesidad de introducir los diversos elementos del lenguaje poco a poco. Al tener expresiones globales, es posible implementar un intérprete de expresiones sin necesidad de resolver los problemas de contexto. Luego se pueden introducir las funciones y finalmente las características orientadas a objetos. De esta forma los estudiantes pueden ir aprendiendo sobre la marcha a medida que adicionan características al lenguaje, siempre teniendo un subconjunto válido del lenguaje implementado.</p>
<h2 id="elementos-básicos-del-lenguaje-de-hulk">Elementos básicos del lenguaje de HULK</h2>
<p>El programa más sencillo en <strong>HULK</strong> es, por supuesto, <em>Hola Mundo</em>:</p>
<pre class="hulk"><code>print(&quot;Hola Mundo&quot;);</code></pre>
<p>En <strong>HULK</strong> un programa puede ser simplemente una expresión (terminada en <code>;</code>), en este caso, la invocación de una función global llamada <code>print</code> (que se presentará más adelante). La cadena de texto <code>&quot;Hola Mundo&quot;</code> es un literal del tipo <code>String</code>, definido en la biblioteca estándar, que se comporta de la forma convencional en la mayoría de los lenguajes de programación más populares: es inmutable, y codificado en UTF8.</p>
<h3 id="tipos-básicos">Tipos básicos</h3>
<p>Además de los literales de cadena, en <strong>HULK</strong> hay 2 tipos básicos adicionales: <code>Number</code>, que representa valores numéricos y <code>Boolean</code> que representa valores de verdad (con los literales usuales <code>True</code> y <code>False</code>).</p>
<p>El tipo <code>Number</code> representa tanto números enteros, como números con coma flotante. La semántica concreta dependerá de la arquitectura. Siempre que sea posible se representará con un valor entero de 64 (o 32) bits, o en su defecto, un valor flotante de 64 (o 32) bits, según permita la arquitectura. Las constantes numéricas se pueden escribir como <code>42</code> (valor entero) o <code>3.14</code> (valor flotante).</p>
<p><strong>HULK</strong> tiene una jerarquía de tipos unificada, cuya raíz es el tipo <code>Object</code>. Todos los demás tipos definidos en el lenguaje son concretos.</p>
<h3 id="expresiones-elementales">Expresiones elementales</h3>
<p>En <strong>HULK</strong> se definen todas las expresiones usuales, en orden decreciente de precedencia:</p>
<ul>
<li>Operaciones lógicas entre expresiones de tipo <code>Boolean</code>: <code>a &amp; b</code>, <code>a | b</code>, <code>!a</code>, siempre evaluadas con cortocircuito.</li>
<li>Operaciones aritméticas entre expresiones de tipo <code>Number</code>: <code>-a</code>, <code>a % b</code>, <code>a * b</code>, <code>a / b</code>, <code>a + b</code>, <code>a - b</code>, con la precedencia y asociatividad usuales, y agrupamiento mediante paréntesis. El resultado es de tipo <code>Number</code> siempre.</li>
<li>Comparaciones entre expresiones de tipo <code>Number</code>: <code>a &lt; b</code>, <code>a &gt; b</code>, <code>a &lt;= b</code>, <code>a &gt;= b</code>, con menor precedencia que las aritméticas, y sin asociatividad.</li>
<li>Comparaciones de igualdad entre expresiones de cualquier tipo: <code>a == b</code>, <code>a != b</code>, con la semántica de igualdad por valor entre expresiones de tipo <code>Number</code>, <code>String</code> o <code>Boolean</code>, e igualdad por referencia en todos los demás tipos. Se permite comparar expresiones de cualquier tipo, y si sus tipos no son compatibles (e.j, <code>&quot;Hola Mundo&quot; == 42</code>) el resultado será <code>False</code>.</li>
<li>El operador infijo <code>@</code> de concatenación entre <code>String</code>: <code>&quot;Hello &quot;@&quot;World&quot; == &quot;Hello World&quot;</code>. Para los casos donde es conveniente, el operador <code>@@</code> adiciona un espacio intermedio: <code>&quot;Hello&quot;@@&quot;World&quot; == &quot;Hello World&quot;</code>.</li>
</ul>
<p>En el espacio de nombres global siempre se encontrarán además las funciones <code>print</code>, <code>read</code> y <code>parse</code>, además de una serie de funciones elementales matemáticas, tales como <code>exp</code>, <code>pow</code>, <code>log</code>, <code>sqrt</code>, <code>min</code> y <code>max</code>.</p>
<p>El valor <code>Null</code> es un valor especial que puede tener cualquier tipo, excepto <code>Number</code> y <code>Boolean</code>. <code>Null</code> representa la no existencia de una instancia asociada a la variable (<em>l-value</em> en caso general) correspondiente, y cualquier operación que se intente sobre un valor <code>Null</code> lanzará un error en tiempo de ejecución, excepto <code>==</code>,que siempre devuelve <code>False</code>, y <code>!=</code> (que siempre devuelve <code>True</code>, incluso entre expresiones ambas iguales a <code>Null</code>. El literal <code>Null</code> es una expresión de tipo <code>Object</code> con valor igual a <code>Null</code>.</p>
<h3 id="variables">Variables</h3>
<p>Las variables en <strong>HULK</strong> se introducen con una expresión <code>let</code>:</p>
<pre class="hulk"><code>let &lt;var&gt;[:&lt;type&gt;]=&lt;init&gt; in &lt;body&gt;</code></pre>
<p>La semántica de la expresión <code>let</code> consiste en que se crea un nuevo ámbito donde se define la variable <code>&lt;var&gt;</code> cuyo valor es el resultado de evaluar <code>&lt;init&gt;</code>, y se evalua en este ámbito la expresión <code>&lt;body&gt;</code>.</p>
<pre class="hulk"><code>let msg:String=&quot;Hola Mundo&quot; in print(msg)</code></pre>
<p>Como se verá, indicar el tipo de una variable al declararla es opcional. Los detalles de la inferencia y verificación de tipos se darán más adelante.</p>
<p>Existe una variante extendida de la expresión <code>let</code> en la que se permite introducir más de una variable:</p>
<pre class="hulk"><code>let x=1, y=2, z=3 in x+(y*z)</code></pre>
<p>Esta variante es semánticamente idéntica a:</p>
<pre class="hulk"><code>let x=1 in let y=2 in let z=3 in x+(y*z)</code></pre>
<p>El cuerpo de una expresión <code>let</code> puede ser también una <em>lista de expresiones</em>, encerradas entre <code>{</code> y <code>}</code> y separadas por <code>;</code>, siendo el valor final de la expresión <code>let</code> el valor de la última expresión de la lista.</p>
<pre class="hulk"><code>let x=0 in {
    print(x==0); # Imprime True
    print(x==1); # Imprime False
}</code></pre>
<p>Una <em>lista de expresiones</em> <strong>no es</strong> una expresión en sí, es decir, no puede ser usada donde quiera que se requiera una expresión. Solamente se puede usar en el cuerpo de algunas construcciones sintácticas que se irán introduciendo poco a poco. Es decir, el siguiente ejemplo <strong>no es válido</strong>:</p>
<pre class="hulk"><code>let x={0;1} in print(x) # NO es válido</code></pre>
<p>Como tampoco lo es:</p>
<pre class="hulk"><code>{1;2} + {3;4;let x=5 in 5} # NO es válido</code></pre>
<p>Ni ningún otro ejemplo similar donde se use un bloque de expresiones como una expresión, excepto en los contextos donde se indique explícitamente más adelante.</p>
<h3 id="asignación">Asignación</h3>
<p>La asignación en <strong>HULK</strong> se realiza con el operador <code>:=</code>, y solamente es posible asignar a una variable que exista en el contexto actual:</p>
<pre class="hulk"><code>let color=&quot;green&quot; in {
    print(color);    # Imprime green
    color:=&quot;blue&quot;;
    print(color);    # Imprime blue
}</code></pre>
<p>La asignación devuelve el valor asignado, y asocia a la derecha. Tiene menor prioridad que todas las expresiones aritméticas:</p>
<pre class="hulk"><code>let x=0, y=0 in {
    y := x := 5 + 5;
    print(x); # 10
    print(y); # 10
    y := (x := 5) + 1;
    print(x); # 5
    print(y); # 6
}</code></pre>
<h3 id="espacios-en-blanco-e-indentación">Espacios en blanco e indentación</h3>
<p>En <strong>HULK</strong> los espacios en blanco no son significativos, ni tampoco la indentación. La sintaxis del lenguaje permite indicar explícitamente, cuando es necesario, el ámbito de un bloque de código. El ejemplo anterior es equivalente a:</p>
<pre class="hulk"><code>let x=1 in
let y=2 in
let z=3 in
    x + (y * z)</code></pre>
<p>O cualquier otra forma de indentar que sea conveniente.</p>
<h3 id="identificadores">Identificadores</h3>
<p>Los identificadores empiezan con un caracter del alfabeto ASCII (o <code>_</code>) y pueden opcionalmente contener números. Ejemplos de identificadores válidos son:</p>
<pre class="hulk"><code>x
name
CamelCase
smallCamelCase
snake_case
_ugly_case
hunter42</code></pre>
<h3 id="funciones">Funciones</h3>
<p><strong>HULK</strong> soporta funciones globales con 2 formas sintácticas muy similares. Una función se define por un nombre, argumentos con tipo opcional, un tipo de retorno también opcional, y el cuerpo. Todas las funciones globales deben ser definidas <strong>antes</strong> de la expresión global que define el <em>cuerpo</em> del programa.</p>
<p>En la primera forma sintáctica, que llamamos &quot;compacta&quot;, el cuerpo de la función debe ser exactamente una expresión (terminada en <code>;</code>):</p>
<pre class="hulk"><code>function isEven(n:Number):Boolean -&gt; n % 2 == 0;</code></pre>
<p>En la segunda forma, que llamaremos &quot;extendida&quot;, el cuerpo de una función puede ser una <em>lista de expresiones</em> separadas por <code>;</code>. El valor de retorno de la función es el valor de la última expresión de la lista. En esta notación <strong>no se incluye</strong> un <code>;</code> al final de la declaración de la función.</p>
<pre class="hulk"><code>function f(a, b, c) {
    a := b + c;
    b := c + a;
    c := a + b;
}

let a=1, b=2, c=3 in print(f(a,b,c)); # Imprime 13</code></pre>
<p>En <strong>HULK</strong> no existe una instrucción ni palabra reservada con semántica similar a <code>return</code>. Todas las funciones tienen un tipo de retorno y devuelven siempre un valor, aunque este valor puede ser <code>Null</code>.</p>
<h3 id="condicionales">Condicionales</h3>
<p>Las expresiones condicionales se introducen con la sintaxis siguiente:</p>
<pre class="hulk"><code>if (&lt;cond&gt;) &lt;body&gt; [elif (&lt;cond&gt;) &lt;body&gt;]* [else &lt;body&gt;]?</code></pre>
<p>Es decir, una parte <code>if</code>, seguida de cero o más partes <code>elif</code> y finalmente una parte <code>else</code> opcional. Una expresión <code>if</code> devuelve el valor de la parte que se ejecuta. Si no se ejecuta ninguna (no hay else), devolverá <code>Null</code>. Si esto invalida la consistencia de tipos (como se verá más adelante), será necesario definir una parte <code>else</code> para garantizar al compilador/intérprete el tipo esperado.</p>
<pre class="hulk"><code>function fib(n) -&gt; if (n &lt;= 1) 1 else fib(n-1) + fib(n-2);</code></pre>
<p>Al igual que con las expresiones <code>let</code> y las funciones, cada cuerpo puede ser o bien una expresión o una lista de expresiones. Si no hay parte <code>else</code> y ninguna rama condicional se ejecuta, se devuelve <code>Null</code>.</p>
<h3 id="ciclos">Ciclos</h3>
<p>La expresión de ciclo más general en <strong>HULK</strong> es un ciclo <code>while</code> con la semántica común:</p>
<pre class="hulk"><code>while (&lt;cond&gt;) &lt;body&gt;</code></pre>
<p>Como ya es usual, <code>&lt;body&gt;</code> puede ser una expresión o una lista de expresiones.</p>
<pre class="hulk"><code>function gcd(a, b) {
    let q = a%b in while (q != 0) {
        a := b;
        b := q;
        q := a%b;
    };

    b;
}</code></pre>
<p>El valor de retorno de la expresión <code>while</code> es el valor de retorno del cuerpo la última vez que se ejecutó el ciclo, o <code>Null</code> en caso de que nunca se ejecute. Si es necesario, se puede adicionar una cláusula <code>else</code> para definir el valor cuando no haya ejecución.</p>
<p>Con esta expresión, la manera más sencilla de implementar un contador (el común ciclo <code>for</code>) es:</p>
<pre class="hulk"><code>let i=0 in while (i &lt; n) {
    # ...
    i := i+1;
}</code></pre>
<h3 id="arrays">Arrays</h3>
<p>En <strong>HULK</strong> existe un tipo nativo con semántica similar al <em>array</em> de los lenguajes de programación de la familia C. Este <em>array</em> <strong>no crece</strong> dinámicamente y <strong>no es covariante</strong> en la asignación. El <em>array</em> es el único tipo genérico que existe en <strong>HULK</strong>, y se declara con una sintaxis especial. Como es de esperar, un <em>array</em> se indiza con una expresión de tipo <code>Number</code> y el valor del primer índice es <code>0</code>. Para los efectos del sistema de tipos, todo tipo <em>array</em> hereda directamente de <code>Object</code>, y no se puede heredar de él.</p>
<pre class="hulk"><code>let a:Number[] = {1, 2, 3, 4}, i:Number=0 in while (i &lt; a.size()) {
    print(a[i]);
    i := i+1;
}</code></pre>
<p>La forma de crear un array vacío es mediante la sintaxis:</p>
<pre class="hulk"><code>let x = new Number[20] in ...</code></pre>
<p>Todo <em>array</em> se inicializa con el valor por defecto del tipo correspondiente, que es <code>0</code> para <code>Number</code>, <code>False</code> para <code>Boolean</code>, y <code>Null</code> para cualquier otro tipo. En <strong>HULK</strong> no existen <em>arrays</em> multidimensionales, pero sí es posible crear <em>arrays</em> de <em>arrays</em> (<em>ad infinitum</em>):</p>
<pre class="hulk"><code>let x = new Number[][10] in ...</code></pre>
<p>En este caso, el único <em>array</em> que se inicializa es el más externo. Cada valor de <code>x[i]</code> se inicializa con <code>Null</code> y debe asignarse explícitamente:</p>
<pre class="hulk"><code>let x = new Number[][10], n=0 in while(n&lt;x.size()) {
    x[i] := new Number[i+1];
}</code></pre>
<p>El tipo de un <em>array</em> complejo como el anterior sería <code>Number[][]</code>.</p>
<h3 id="inicialización-automática-de-arrays">Inicialización automática de <em>arrays</em></h3>
<p>Cuando se instancia un <em>array</em>, es posible inicializarlo automáticamente mediante la sintaxis:</p>
<pre class="hulk"><code>new &lt;type&gt;[&lt;length&gt;] { &lt;index&gt; -&gt; &lt;expr&gt; }</code></pre>
<p>Donde <code>&lt;expr&gt;</code> es una expresión que devuelve el valor del i-ésimo elemento, indizado por la variable <code>&lt;index&gt;</code>. Por ejemplo:</p>
<pre class="hulk"><code>new Number[20]{ i -&gt; 2*i+1 }</code></pre>
<p>Es equivalente a:</p>
<pre class="hulk"><code>let x = new Number[20], i=0 in while (i&lt;x.size()) {
    x[i] := 2*i+1;
    i := i+1;
    x;
}</code></pre>
<p>La expresión de inicialización es un atajo sintáctico para no escribir un ciclo de inicialización. Por tal motivo, se comporta exactamente igual que dicho ciclo. Esta expresión crea un nuevo contexto donde se define la variable <code>&lt;index&gt;</code>. Este contexto es hijo del contexto donde se crea el <em>array</em>. En particular, <strong>tiene acceso</strong> a la variable que referencia al propio <em>array</em> (en caso de existir). Por ejemplo, la siguiente expresión es válida:</p>
<pre class="hulk"><code>let x = new Number[20]{ i -&gt; if (i&lt;=1) 0 else x[i-1] + x[i-2] }</code></pre>
<p>Pues es equivalente a:</p>
<pre class="hulk"><code>let x = new Number[20], i=0 in while (i&lt;x.size()) {
    x[i] := if (i&lt;=1) 0 else x[i-1] * x[i-2];
    i := i+1;
    x;
}</code></pre>
<p>De esta forma es posible inicializar <em>arrays</em> complejos en una sola expresión, como en el ejemplo siguiente:</p>
<pre class="hulk"><code>new Number[][100] { i -&gt; new Number[100] { j -&gt; i*j } }</code></pre>
<p>Que es equivalente a:</p>
<pre class="hulk"><code>let x = new Number[][100], i=0 in while (i&lt;x.size()) {
    x[i] := new Number[100];
    let j=0 in while (j &lt; x[i].size()) {
        x[i][j] := i * j;
        j := j+1;
    };
    i := i+1;
    x;
}</code></pre>
<p>Todos los <em>arrays</em> en <strong>HULK</strong> tienen semántica de enlace por referencia.</p>
<h3 id="lidiando-con-valores-null">Lidiando con valores <code>Null</code></h3>
<p>Si una variable tiene valor <code>Null</code>, se lanzará un error en tiempo de ejecución si se intenta cualquier operación sobre ella (expecto <code>==</code> y <code>!=</code>). Siempre es posible evitar esto comprobando explícitamente:</p>
<pre class="hulk"><code>if (x != Null) x.value else 0</code></pre>
<p>Para estos casos, <strong>HULK</strong> introduce una sintaxis específica:</p>
<pre class="hulk"><code>with (&lt;expr&gt; as &lt;id&gt;) &lt;expr&gt; [else &lt;expr&gt;]</code></pre>
<p>Por ejemplo, en este caso:</p>
<pre class="hulk"><code>with (x as o) o.value else 0</code></pre>
<p>La ventaja de esta sintaxis es que dentro del cuerpo de <code>with</code> se garantiza que <code>&lt;id&gt;</code> nunca será <code>Null</code>. Además, la variable <code>&lt;id&gt;</code> es <strong>una referencia de de solo lectura</strong> a la expresión <code>&lt;expr&gt;</code>, y el compilador impide que se le hagan asiganciones. De modo que es posible garantizar que este código nunca lanzará excepción en tiempo de ejecución por accesos o usos de <code>&lt;id&gt;</code>.</p>
<h3 id="prioridad-de-las-expresiones">Prioridad de las expresiones</h3>
<p>Las expresiones <code>let</code>, <code>if</code>, <code>while</code>, <code>case</code> y <code>with</code> tienen <strong>menor prioridad</strong> que todas las expresiones elementales (aritméticas, etc.), y siempre asocian a la derecha. Por lo tanto, para poder usar una de estas expresiones dentro de una expresión aritmética, por ejemplo, se deben encerrar entre paréntesis.</p>
<p>Por ejemplo, el siguiente es un caso común:</p>
<pre class="hulk"><code>let x=5 in let y=8 in x+y</code></pre>
<p>Que es equivalente a:</p>
<pre class="hulk"><code>let x=5 in (let y=8 in (x+y))</code></pre>
<p>Sin embargo, el siguiente caso <strong>no es válido</strong>, pues no se puede sumar con <code>let</code> sin parentizar (<code>let</code> tiene menor prioridad):</p>
<pre class="hulk"><code>let x=5 in x + let y=8 in y # NO es valido</code></pre>
<p>La forma correcta es:</p>
<pre class="hulk"><code>let x=5 in x + (let y=8 in y)</code></pre>
<p>Por último, el bloque <code>else</code> siempre asocia al <code>if</code> (o <code>while</code>) más cercano. Es decir, la siguiente expresión:</p>
<pre class="hulk"><code>if (a) if (b) y else z</code></pre>
<p>Es no ambigua, y equivalente a:</p>
<pre class="hulk"><code>if (a) (if (b) y else z)</code></pre>
<p>Por otro lado, la invocación de funciones, instanciación, el acceso a miembros (e.g., <code>self.x</code>) y el indizado en <em>arrays</em> tienen mayor prioridad que todas las expresiones elementales aritméticas.</p>
<h2 id="orientación-a-objetos-en-hulk">Orientación a objetos en HULK</h2>
<p>Además de las características estructuradas y funcionales presentadas, el lenguaje <strong>HULK</strong> soporta el concepto de <em>tipo</em>, implementado mediante <em>clases</em>. Todos los valores creados en un programa de <strong>HULK</strong> tienen un tipo asociado, y este tipo no puede ser cambiado en tiempo de ejecución. Por esto decimos que <strong>HULK</strong> es un lenguaje con tipado estático.</p>
<p>Aparte de los tipos nativos presentados (<code>Number</code>, <code>Boolean</code> y <code>String</code>), es posible definir nuevos tipos mediante la sintaxis:</p>
<pre class="hulk"><code>class &lt;name&gt;[&lt;args&gt;] [is &lt;base&gt;[&lt;init&gt;]] {
    [&lt;attribute&gt;;]*
    [&lt;method&gt;]*
}</code></pre>
<p>Todas las clases deben ser definidas <strong>antes</strong> que todas las funciones globales, pero esto <em>no impide</em> que dentro del cuerpo de un método en una clase (explicado más adelante), se llame a una función global, o se use una clase definida posteriormente.</p>
<p>Todas las clases en <strong>HULK</strong> heredan de una clase base. En caso de no especificarse, esta clase será <code>Object</code>, que es la raíz de la jerarquía de tipos en <strong>HULK</strong>. Los tipos básicos <code>Number</code>, <code>String</code> y <code>Boolean</code> también heredan de <code>Object</code>, pero a diferencia del resto de las clases, <strong>no es permitido heredar de los tipos básicos</strong>. Esto se restringe ya que los tipos básicos generalmente se implementan de forma especial para garantizar una mayor eficiencia, y por lo tanto deben ser tratados con cuidado en la jerarquía de tipos.</p>
<h3 id="atributos-y-métodos">Atributos y métodos</h3>
<p>Dentro del cuerpo de una clase se pueden definir dos tipos de elementos: atributos y métodos. Los atributos se definen con un nombre, un tipo opcional, y una expresión de inicializacion <em>obligatoria</em> (terminado en <code>;</code>):</p>
<pre class="hulk"><code>class Point {
    x:Number = 0;
    y:Number = 0;
}</code></pre>
<p>Todos los atributos en <strong>HULK</strong> son <strong>privados</strong>, es decir, no está permitido acceder a ellos desde otras clases, ni desde clases herederas.</p>
<p>Los métodos se definen con una sintaxis muy similar a las funciones globales. La única diferencia es que en el contexto de un método siempre existe una variable implícita <code>self</code> que referencia a la instancia en cuestión. Es obligatorio acceder a los atributos y métodos de una clase a través de <code>self</code>, <strong>nunca</strong> usando su nombre directamente.</p>
<pre class="hulk"><code>class Point {
    x:Number = 0;
    y:Number = 0;

    translate(x,y) -&gt; Point(self.x + x, self.y + y);
    length() -&gt; sqrt(self.x * self.x + self.y * self.y);
}</code></pre>
<p>Todos los atributos deben ser definidos <strong>antes</strong> que todos los métodos, y sus expresiones de inicialización no pueden utilizar métodos de la propia clase, ni valores de otros atributos (aunque sí pueden utilizar funciones globales). Todos los métodos en <strong>HULK</strong> son <strong>públicos</strong> y <strong>virtuales</strong>, redefinibles por los herederos. Además, todos los métodos son de instancia, no existen métodos estáticos, y no existe sintaxis para invocar a un método que no sea a través de una referencia a una instancia de una clase.</p>
<h3 id="instanciando-clases">Instanciando clases</h3>
<p>Para obtener una instancia de una clase en <strong>HULK</strong> se utiliza el nombre de la clase como si fuera un método, precedido la palabra clave <code>new</code>.</p>
<pre class="hulk"><code>let p = new Point() in print(p.translate(5,3).length());</code></pre>
<p>Si se desea inicializar los atributos de la clase, se pueden definir <em>argumentos de clase</em>, y su valor usarse en la inicialización de los atributos:</p>
<pre class="hulk"><code>class Point(x:Number, y:Number) {
    x:Number = x;
    y:Number = y;
    # ...
}</code></pre>
<p>Una vez definidos argumentos de clase, es obligatorio proporcionar su valor al construir la clase:</p>
<pre class="hulk"><code>let p = new Point(5,3) in print(p.length());</code></pre>
<h3 id="redefinición-y-polimorfismo">Redefinición y polimorfismo</h3>
<p>En <strong>HULK</strong> todas las invocaciones a métodos de una instancia son polimórficas. Todos los métodos en <strong>HULK</strong> son virtuales, y pueden ser redefinidos, siempre que se mantenga la misma signatura (cantidad y tipo de los parámetros y retorno). La redefinición se realiza implícitamente si se define en una clase heredera un método con el mismo nombre de una clase ancestro.</p>
<pre class="hulk"><code>class Person(name:String) {
    name:String=name;
    def greet() -&gt; &quot;Hello&quot; @@ self.name;
}

class Colleague is Person {
    greet() -&gt; &quot;Hi&quot; @@ self.name;
}</code></pre>
<p>Al heredar de una clase se heredan por defecto las definiciones de los argumentos de clase. Por lo tanto, al instanciar una clase heredera, es obligatorio proporcionar los valores de los argumentos:</p>
<pre class="hulk"><code>let p = new Colleague(&quot;Pete&quot;) in print(p.greet()); # Hi Pete</code></pre>
<p>Sin embargo, <strong>no está permitido</strong> usar estos argumentos de clase implícitos en la inicialización de atributos de una clase heredera. Si es necesario usarlos, se pueden redefinir explícitamente en la clase heredera. Por otro lado, siempre que se redefinan argumentos de clase en una clase heredera, será necesario indicar explícitamente cómo se evaluan los argumentos de la clase padre en términos de los argumentos de la clase heredera:</p>
<pre class="hulk"><code>class Noble(title:String, who:String) is Person(title @@ who) { }

let p = new Noble(&quot;Sir&quot;, &quot;Thomas&quot;) in print(p.greet()); # Hello Sir Thomas</code></pre>
<h3 id="evaluando-el-tipo-dinámico">Evaluando el tipo dinámico</h3>
<p>La expresión <code>case</code> permite comparar el tipo dinámico de una expresión con una lista de tipos posibles. Su sintaxis es la siguiente:</p>
<pre class="hulk"><code>case &lt;expr&gt; of {
    [&lt;id&gt;:&lt;type&gt; -&gt; &lt;body&gt; ;]+
}</code></pre>
<p>Esta expresión compara el tipo dinámico de <code>&lt;expr&gt;</code> contra cada uno de los tipos <code>&lt;type&gt;</code>, y ejecuta el <code>&lt;body&gt;</code> correspondiente a la rama del ancestro más cercano:</p>
<pre class="hulk"><code>class A { }
class B is A { }
class C is B { }
class D is A { }

case new C() of {
    a:A -&gt; print(&quot;A&quot;);
    b:B -&gt; print(&quot;B&quot;); # Se ejecuta esta rama
    d:D -&gt; print(&quot;D&quot;);
}</code></pre>
<p>En caso de ninguna rama ser válida en tiempo de ejecución, se lanza un error. En caso de poderse inferir el tipo de <code>&lt;expr&gt;</code>, se intentará validar la compatibilidad con los tipos <code>&lt;type&gt;</code>, y se lanzará un error semántico de existir. El cuerpo de una rama cualquiera puede ser una lista de expresiones entre <code>{</code> y <code>}</code> si fuera necesario, como sucede con las funciones.</p>
<p>Existe una versión compacta también de <code>case</code> cuando hay una sola rama, con la forma:</p>
<pre class="hulk"><code>case &lt;expr&gt; of &lt;id&gt;:&lt;type&gt; -&gt; &lt;body&gt;</code></pre>
<p>Esta forma puede usarse para evaluar un &quot;downcast&quot; en <strong>HULK</strong>, cuando se conoce con certeza el tipo dinámico de un objeto.</p>
<p>Por ejemplo, el siguiente programa lanza error semántico pues <code>o</code> es de tipo estático <code>Object</code>, explícitamente declarado, por lo que no se puede sumar.</p>
<pre class="hulk"><code>function dunno():Object -&gt; 40;

let o:Object = something() in o + 2; # error semántico</code></pre>
<p>Sin embargo, usando <code>case</code> se puede forzar al verificador de tipos a que infiera <code>Number</code> para esta expresión, lanzando error en tiempo de ejecución si realmente el tipo dinámico fuera otro.</p>
<pre class="hulk"><code>function dunno():Object -&gt; 40;

let o:Object = something() in case o of y:Number -&gt; y + 2;</code></pre>
<h3 id="verificación-e-inferencia-de-tipos">Verificación e inferencia de tipos</h3>
<p>Un programa en <strong>HULK</strong> no necesita especificar todas las anotaciones de tipos, si son inferibles dado el contexto. Formalizar precisamente en qué casos es posible inferir o no el tipo de una declaración es un problema complicado, y no lo intentaremos en este punto. Por el contrario, presentaremos algunos ejemplos donde es posible inferir el tipo, y otros ejemplos donde el mecanismo de inferencia de tipos de <strong>HULK</strong> no será capaz de deducirlo.</p>
<p>El caso más sencillo, es cuando en una declaración de variable se omite el tipo. En este caso, el tipo se infiere de la expresión de inicialización:</p>
<pre class="hulk"><code>let x=3+2 in case x of y:Number -&gt; print(&quot;Ok);</code></pre>
<p>De igual forma sucede con los atributos de una clase, cuando pueden ser inferidos por el tipo de la expresión de inicialización:</p>
<pre class="hulk"><code>class Point(x:Number, y:Number) {
    x=x;
    y=y;
    # ...
}</code></pre>
<p>Un caso más complejo es cuando se deja sin especificar el tipo de retorno de una función, pero puede ser inferido por a partir de su cuerpo:</p>
<pre class="hulk"><code>function succ(n:Number) -&gt; n + 1;</code></pre>
<p>En el caso anterior, es fácil inferir el tipo de retorno de <code>succ</code> porque la expresión retorna exactamente el mismo tipo que un argumento. En estos casos, es posible incluso no especificar el tipo del argumento, ya que el operador <code>+</code> solo está definido para <code>Number</code>:</p>
<pre class="hulk"><code>function succ(n) -&gt; n + 1;</code></pre>
<p>Sin embargo, a veces no es posible inferir el tipo de un argumento a partir de su uso <em>dentro del cuerpo</em> de una función. En el caso siguiente, aunque sabemos que el tipo del argumento <code>p</code> debe ser <code>Point</code> para aceptar la invocación, <em>no se garantiza</em> que el mecanismo de inferencia de tipos deba deducirlo (ya que en el futuro puede haber otras clases con un método <code>translate</code>). Dependiendo de la implementación, en estos casos se permite lanzar error semántico indicando que no fue posible inferir el tipo del argumento <code>p</code>.</p>
<pre class="hulk"><code>function step(p) -&gt; p.translate(1,1);

let p = new Point(0,0) in step(p); # Puede lanzar error semántico</code></pre>
<p>Por último, especial complejidad acarrean las funciones recursivas:</p>
<pre class="hulk"><code>function fact(n) -&gt; if (n&lt;0) 1 else n*fact(n-1);</code></pre>
<p>El ejemplo anterior permite inferir simultáneamente el tipo del argumento <code>n</code> y del retorno, ya que se usa el retorno de la función recursiva en una operación <code>+</code> que solo está definida para <code>Number</code>. Sin embargo, en el ejemplo siguiente:</p>
<pre class="hulk"><code>function ackermann(m, n) -&gt;
    if   (m==0) n+1
    elif (n==0) ackermann(m-1, 1)
    else        ackermann(m-1, ackermann(m, n-1));</code></pre>
<p>Como el tipo de retorno no se utiliza explícitamente en una operación matemática, no es trivial deducir que su tipo de retorno es <code>Number</code>, ya que <code>Object</code> funcionaría también como tipo de retorno. En estos casos, se desea que el mecanismo de inferencia deduzca <em>el tipo más concreto</em> para el retorno y <em>el tipo más abstracto</em> para los argumentos que sea posible.</p>
<p>Finalmente, dos funciones mutuamente recursivas:</p>
<pre class="hulk"><code>def f(a, b) -&gt; is (a==1) b else g(a+1, b/2);
def g(a, b) -&gt; if (b==1) a else f(a/2, b+1);</code></pre>
<p>En este caso, es posible teóricamente inferir que <code>f</code> y <code>g</code> deben ambos retornar tipo <code>Number</code>, pero dada la complejidad de manejar la inferencia de tipos en más de una función a la vez, no se garantiza que sea posible deducir los tipos en este caso.</p>
<p>Cuando se crea un <em>array</em>, es posible inferir el tipo estático si se provee una expresión de inicialización:</p>
<pre class="hulk"><code>let x = new [20]{ i -&gt; (i+1)*(i+2) } in ... # Infiere Number</code></pre>
<p>Sin embargo, si en la expresión de inicialización se usa el propio <em>array</em>, entonces no se garantiza que sea posible inferir el tipo:</p>
<pre class="hulk"><code>let x = new [20]{ i -&gt; if (i&lt;=1) 1 else x[i-1] + x[i-2] } in ...</code></pre>
<h3 id="null-safety-en-hulk"><em>Null-safety</em> en <strong>HULK</strong></h3>
<p>Gracias a la existencia de la instrucción <code>with</code>, un compilador de <strong>HULK</strong> debe ser capaz de inferir para un programa si es seguro garantizar que no habrá errores en ejecución por variables <code>Null</code>. Es posible entonces que un compilador genere en estos casos un código más eficiente, al no tener que validar las referencias en todos los accesos y usos. En todos los casos en que no se pueda garantizar la <em>null-safety</em>, el compilador debe emitir una advertencia en tiempo de compilación (<em>warning</em>).</p>
<p>Opcionalmente, el compilador de <strong>HULK</strong> puede ejecutarse en modo <strong>null-safe</strong>. En este modo, las advertencias por violación de <em>null-safety</em> se convierten en errores de compilación.</p>
<p>Nótese que no es estrictamente necesario usar <code>with</code> en todos los casos para garantizar la <em>null-safety</em>. Hay casos en que por el contexto es posible garantizar la seguridad. El caso más sencillo es cuando se usan variables de tipo <code>Number</code> o <code>Boolean</code>, que por definición no pueden contener un valor <code>Null</code>.</p>
<p>Un caso más interesante es cuando se puede inferir por la inicialización de una variable, por ejemplo:</p>
<pre class="hulk"><code>let x = new Person(&quot;John Doe&quot;) in print(x.greet());</code></pre>
<p>En este caso se puede inferir que <code>x</code> nunca será <code>Null</code> pues no existe ninguna asignación, y el valor de la expresión <code>Person(...)</code> nunca es <code>Null</code>.</p>
<p>Por el contrario, si se usa un ciclo o una expresión <code>if</code> sin parte <code>else</code>, no es posible garantizar <em>null-safety</em>, incluso cuando realmente el valor de la expresión no pueda ser <code>Null</code>.</p>
<pre class="hulk"><code>let i=n, x=(while (i &gt; 0) i:=i-1) in print(x);</code></pre>
<p>Así mismo, en los argumentos de una función nunca será posible garantizar <em>null-safety</em>.</p>
<p>De manera general el compilador de <strong>HULK</strong> hará todo lo posible por inferir si cada uso es <em>null-safe</em>, incluso cuando no se introduzca una expresión <code>with</code>. En los casos en que no sea posible inferirlo, el programador siempre podrá introducir una expresión <code>with</code> para satisfacer al compilador.</p>
<h2 id="formalización-del-lenguaje-hulk">Formalización del lenguaje HULK</h2>
<p>En esta sección presentaremos una descripción formal de <strong>HULK</strong>, en términos sintácticos, semánticos y operacionales. Esta sección debe servir como referencia para la construcción de un compilador de <strong>HULK</strong>, pero recomendamos las secciones anteriores que explican de forma más intuitiva todos los elementos relevantes del lenguaje.</p>
<h3 id="sintaxis-de-hulk">Sintaxis de HULK</h3>
<p>Una gramática posible para <strong>HULK</strong> se muestra a continuación. Nótese que por motivos didácticos, esta gramática es ambigua. En particular, la asociatividad y prioridad de los distintos tipos de expresiones se deja sin resolver, para dar espacio a los estudiantes a que resuelvan estos problemas.</p>
<p>Los terminales de <strong>HULK</strong> son:</p>
<pre class="grammar"><code>NUMBER  := [0-9]+(.[0-9]+)?
STRING  := &quot; UNICODE* &quot; # Todos los caracteres unicode válidos
BOOLEAN := True | False
LITERAL := NUMBER | STRING | BOOLEAN
ID      := [a-zA-Z_][a-zA-Z0-9]*</code></pre>
<p>Un programa en <strong>HULK</strong> tiene tres partes: declaraciones de clases, declaraciones de funciones y una expresión opcional terminada en punto y coma (<code>;</code>):</p>
<pre class="grammar"><code>&lt;program&gt; := [&lt;class&gt;]* [&lt;function&gt;]* [&lt;expr&gt; ;]</code></pre>
<p>Una clase contiene atributos y métodos, y opcionalmente declaraciones de argumentos de clases:</p>
<pre class="grammar"><code>&lt;class&gt;  := class ID [(&lt;params&gt;)] [is ID [(&lt;args&gt;)]] { [&lt;attr&gt; ;]* [&lt;method&gt;]* }
&lt;params&gt; := ID [: ID] [, ID [: ID]]*
          | epsilon
&lt;args&gt;   := ID = &lt;expr&gt; [, ID = &lt;expr&gt;]*
          | epsilon</code></pre>
<p>Los atributos tiene un nombre, opcionalmente un tipo y una inicialización obligatoria.</p>
<pre class="grammar"><code>&lt;attr&gt; := ID [: ID] = &lt;expr&gt;</code></pre>
<p>Un método tiene un nombre, argumentos, un tipo de retorno opcional y un cuerpo. Hay 2 tipos de notaciones para métodos, una donde el cuerpo es una expresión simple (y termina en <code>;</code>) y otra donde el cuerpo es una lista de expresiones.</p>
<pre class="grammar"><code>&lt;method&gt; := ID ( &lt;params&gt; ) [: ID] &lt;body&gt;
&lt;body&gt;   := -&gt; &lt;expr&gt; ;
          | { [&lt;expr&gt; ;]+ }</code></pre>
<p>Una función global tiene una signatura muy parecida a un método, pero requiere la palabra clave <code>function</code>:</p>
<pre class="grammar"><code>&lt;function&gt; := function ID ( &lt;params&gt; ) [: ID] &lt;body&gt;</code></pre>
<p>Finalmente las expresiones se dividen en 7 tipos fundamentales:</p>
<pre class="grammar"><code>&lt;expr&gt; := &lt;let-expr&gt;
        | &lt;if-expr&gt;
        | &lt;while-expr&gt;
        | &lt;case-expr&gt;
        | &lt;assign-expr&gt;
        | &lt;elem-expr&gt;</code></pre>
<p>Una expresión de tipo <code>let</code> se compone de un bloque de inicializaciones, y un cuerpo. Igual que las funciones, este cuerpo puede ser simple o compuesto por una lista de expresiones:</p>
<pre class="grammar"><code>&lt;let-expr&gt;  := let &lt;decls&gt; in &lt;expr-body&gt;
&lt;decls&gt;     := &lt;decl&gt; [, &lt;decl&gt;]*
&lt;decl&gt;      := ID [: ID] = &lt;expr&gt;
&lt;expr-body&gt; := &lt;expr&gt;
             | { [&lt;expr&gt; ;]+ }</code></pre>
<p>Una expresión de tipo <code>if</code> tiene un conjunto de condiciones y opcionalmente una cláusula <code>else</code>:</p>
<pre class="grammar"><code>&lt;if-expr&gt; := if ( &lt;expr&gt; ) &lt;expr-body&gt;
             [elif ( &lt;expr&gt; ) &lt;expr-body&gt;]*
             [else &lt;expr-body&gt;]</code></pre>
<p>Una expresión de tipo <code>while</code> tiene una condición, un cuerpo, y opcionalmente una cláusula <code>else</code>:</p>
<pre class="grammar"><code>&lt;while-expr&gt; := while ( &lt;expr&gt; ) &lt;expr-body&gt;
                [else &lt;expr-body&gt;]</code></pre>
<p>Una expresión de tipo <code>case</code> tiene una expresión y un conjunto de ramas compuestas por identificador, tipo, y expresión de retorno:</p>
<pre class="grammar"><code>&lt;case-expr&gt; := case &lt;expr&gt; of &lt;case-body&gt;
&lt;case-body&gt; := ID : ID -&gt; &lt;expr-body&gt;
             | { [ID : ID -&gt; &lt;expr-body&gt; ;]* }</code></pre>
<p>Una asignación tiene una locación a la izquierda y una expresión a la derecha:</p>
<pre class="grammar"><code>&lt;assing-expr&gt; := &lt;loc&gt; &#39;:=&#39; &lt;expr&gt;
&lt;loc&gt;         := &lt;loc&gt; &#39;[&#39; &lt;expr&gt; &#39;]&#39;
               | &lt;loc&gt; . &lt;expr&gt;
               | ID</code></pre>
<p>Las expresiones elementales se componen de todas las operaciones lógicas, aritméticas, etc., además de la invocación a funciones globales, métodos, y atributos:</p>
<pre class="grammar"><code>&lt;elem-expr&gt; := &lt;expr&gt; == &lt;expr&gt; | &lt;expr&gt; != &lt;expr&gt;
             | &lt;expr&gt; &lt; &lt;expr&gt;  | &lt;expr&gt; &gt; &lt;expr&gt;
             | &lt;expr&gt; &lt;= &lt;expr&gt; | &lt;expr&gt; &gt;= &lt;expr&gt;
             | &lt;expr&gt; &amp; &lt;expr&gt;  | &lt;expr&gt; &#39;|&#39; &lt;expr&gt; | !&lt;expr&gt;
             | &lt;expr&gt; @ &lt;expr&gt;  | &lt;expr&gt; @@ &lt;expr&gt;
             | &lt;expr&gt; + &lt;expr&gt;  | &lt;expr&gt; - &lt;expr&gt;
             | &lt;expr&gt; % &lt;expr&gt;  | &lt;expr&gt; * &lt;expr&gt;   | &lt;expr&gt; / &lt;expr&gt;
             | &lt;expr&gt; [ &#39;[&#39; &lt;expr&gt; &#39;]&#39; ]?
             | [&lt;expr&gt; .] ID [( &lt;args&gt; )]?
             | -&lt;expr&gt; | ( &lt;expr&gt; )</code></pre>
<h3 id="semántica-de-tipos">Semántica de tipos</h3>
<h3 id="reglas-para-la-inferencia-de-tipos">Reglas para la inferencia de tipos</h3>
<h3 id="semántica-operacional">Semántica operacional</h3>
<h2 id="implementando-un-compilador-de-hulk">Implementando un Compilador de <strong>HULK</strong></h2>
<p>La implementación de un compilador de <strong>HULK</strong> tiene varios detalles y retos interesantes. A continuación queremos discutir algunas cuestiones que facilitarán esta tarea.</p>
<h3 id="flujo-de-trabajo">Flujo de trabajo</h3>
<h3 id="casos-de-prueba">Casos de prueba</h3>
<nav>
    <a href="chap7.html" class="navigation previous">Anterior</a>
    </nav>
</body>
</html>
