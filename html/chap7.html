<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<nav>
    <a href="chap6.html" class="navigation previous">Anterior</a>
      <a href="chap8.html" class="navigation next">Siguiente</a>
  </nav>
<h1 id="generación-de-código">Generación de Código</h1>
<h2 id="código-de-3-direcciones-orientado-o-objetos-cil">Código de 3 Direcciones Orientado o Objetos (CIL)</h2>
<p>Para la generación de código intermedio de COOL a MIPS vamos a diseñar un lenguaje de máquina con capacidades orientadas a objeto. Este lenguaje nos va a permitir generar código de COOL de forma más sencilla, ya que el salto directamente desde COOL a MIPS es demasiado complejo. Este lenguaje se denomina CIL, <strong>3-address object-oriented</strong>.</p>
<p>Un programa en CIL tiene 3 secciones:</p>
<h3 id="jerarquía-de-tipos">Jerarquía de Tipos</h3>
<p>La primera es una sección (opcional) de declaración de tipos:</p>
<pre class="cil"><code>.TYPES

type A {
    attribute x ;
    method f : f1;
}

type B {
    attribute x ;
    attribute y ;
    method f : f1 ;
    method g : f2 ;
}

type C {
    attribute x ;
    attribute z ;
    method f : f2;
}</code></pre>
<p>El &quot;tipo&quot; de los atributos en CIL no importa, pues todos los atributos son de tipo numérico. El único tipo por valor es <code>Integer</code> que almacena un entero de 32 bits. Todos los demás tipos son por referencia, y por lo tanto se representan por el valor de 32 bits del lugar de memoria virtual donde se ubican.</p>
<p>El orden de los atributos es muy importante, ya que luego veremos instrucciones para acceder a los atributos que usan realmente la dirección de memoria del atributo. Esta dirección está definida por el orden en que se declaran. Por este motivo, por ejemplo, si la clase <code>A</code> hereda de la clase <code>B</code>, y la clase <code>B</code> tiene un atributo <code>x</code>, es importante que en ambas declaraciones de tipos haya un atributo <code>x</code> y además que esté en el mismo orden. Lo mismo sucede con los métodos. Más adelante cuando completemos la generación de código veremos estos detalles más en profundidad.</p>
<h3 id="datos">Datos</h3>
<p>En la sección de datos se declaran todas las cadenas de texto constantes que serán usadas durante todo el programa.</p>
<pre class="cil"><code>.DATA

msg = &quot;Hello World&quot;;</code></pre>
<h3 id="funciones">Funciones</h3>
<blockquote>
<p>Se toma como convenio que la primera función declarada es la función que se ejecuta al iniciar el programa.</p>
</blockquote>
<pre class="cil"><code>.CODE

function f1 {
    ...
}

function f2 {
    ...
}</code></pre>
<p>El cuerpo de cada función se divide a su vez en dos secciones. Primero se definen todos los parámetros y variables locales, y luego las instrucciones en sí:</p>
<pre class="cil"><code>function f1 {
    PARAM x;
    PARAM y;

    LOCAL a;
    LOCAL b;

    &lt;body&gt;
}</code></pre>
<p>El cuerpo de una función en CIL se compone de una secuencia de instrucciones, que siempre reciben a lo sumo 3 argumentos, uno para almacenar el valor de retorno, y 2 operandos.</p>
<p>Entre las instrucciones básicas tenemos:</p>
<h3 id="asignación-simple">Asignación simple</h3>
<pre class="cil"><code>x = y ;</code></pre>
<h3 id="operaciones-aritméticas">Operaciones aritméticas</h3>
<pre class="cil"><code>x = y + z ;</code></pre>
<h3 id="acceso-a-atributos">Acceso a atributos</h3>
<p>El acceso a atributos se utiliza para obtener el valor de un atributo almacenado en un lugar de la memoria en una variable temporal.</p>
<pre class="cil"><code>x = GETATTR y b ;</code></pre>
<p>Es equivalente a <code>x = y.b</code>.</p>
<pre class="cil"><code>SETATTR y b x ;</code></pre>
<p>El &quot;atributo&quot; <code>b</code> realmente es solamente la dirección de memoria donde está el atributo.</p>
<p>Es equivalente a <code>y.b = x</code>.</p>
<h3 id="acceso-a-arrays">Acceso a arrays</h3>
<p>Cuando una variable es de un tipo array (o <code>string</code>), se puede acceder al iésimo elemento:</p>
<pre class="cil"><code>x = GETINDEX a i ;</code></pre>
<p>O asignar un valor:</p>
<pre class="cil"><code>SETINDEX a i x ;</code></pre>
<h3 id="manipulación-de-memoria">Manipulación de memoria</h3>
<p>Para crear un nuevo objeto existe una instrucción de alocación de memoria:</p>
<pre class="cil"><code>x = ALLOCATE T ;</code></pre>
<p>Esta instrucción crea en memoria espacio suficiente para alojar un tipo <code>T</code> y devuelve en <code>x</code> la dirección de memoria de inicio del tipo.</p>
<p>Para obtener el tipo dinámico de una variable se utiliza la sintaxis:</p>
<pre class="cil"><code>t = TYPEOF x ;</code></pre>
<p>Para crear arrays se utiliza una sintaxis similar:</p>
<pre class="cil"><code>x = ARRAY y ;</code></pre>
<p>Donde <code>y</code> es una variable de tipo numérico (como todas) que define el tamaño del array.</p>
<h3 id="invocación-de-métodos">Invocación de métodos</h3>
<p>Para invocar un método se debe indicar el tipo donde se encuentra el método, además del método en concreto que se desea ejecutar.</p>
<pre class="cil"><code>x = CALL f ;</code></pre>
<p>Este llamado es una invocación estática, es decir, se llama exactamente al método <code>f</code>.</p>
<p>Además existe un llamado dinámico, donde el método <code>f</code> se buscan en el tipo <code>T</code> y se resuelve la dirección del método real al que invocar:</p>
<pre class="cil"><code>x = VCALL T f ;</code></pre>
<p>Todos los parámetros deben ser pasados de antemano, con la siguiente instrucción:</p>
<pre class="cil"><code>ARG a ;</code></pre>
<p>Cada método espera que los parámetros estén ubicados en la memoria en el mismo orden en que están declarados en el método. Es responsabilidad del que invoca pasar los parámetros de forma adecuada.</p>
<p>En particular, para todos los métodos &quot;de instancia&quot;, que tiene un argumento <code>self</code> o similar, es responsabilidad del que invoca pasar este <code>self</code> como primer parámetro.</p>
<h3 id="saltos">Saltos</h3>
<p>Los saltos condicionales en CIL siempre tienen una condición y una instrucción de salto:</p>
<pre class="cil"><code>IF x GOTO label ;</code></pre>
<p>Donde <code>label</code> tiene que ser una etiqueta declarada en algún lugar de la propia función. La etiqueta puede estar declarada después de su uso. Si la etiqueta no está declarada correctamente, el resultado de la operación no está definido.</p>
<pre class="cil"><code>LABEL label ;</code></pre>
<p>Los saltos incondicionales simplemente se ejecutan con:</p>
<pre class="cil"><code>GOTO label ;</code></pre>
<p>Como en CIL no existen variables <em>booleanas</em>, el valor de verdad de una expresión es realmente que la expresión sea distinta de cero, por lo tanto, los siguientes saltos son equivalentes:</p>
<pre class="cil"><code>x = y != z;
IF x GOTO label ;

x = y - z
IF x GOTO label ;</code></pre>
<h3 id="retorno-de-función">Retorno de Función</h3>
<p>Finalmente todas las funciones deben tener una instrucción de retorno:</p>
<pre class="cil"><code>RETURN x ;</code></pre>
<p>Esta instrucción pone el valor de <code>x</code> en la dirección de retorno de <code>f</code> y además termina la ejecución de la función. Si esta instrucción no se ejecuta en el cuerpo de una función el resultado de la invocación de la función no está bien definido. Si no importa el valor de retorno de la función, simplemente se puede usar cualquiera de las siguientes dos variantes, (que son equivalentes):</p>
<pre class="cil"><code>RETURN ;

RETURN 0 ;</code></pre>
<h3 id="funciones-de-cadena">Funciones de cadena</h3>
<p>Las cadenas de texto se pueden manipular con funciones especiales. Primero es necesario obtener una dirección a la cadena:</p>
<pre class="cil"><code>x = LOAD msg ;</code></pre>
<p>Luego se puede operar sobre una cadena con instrucciones tales como <code>LENGTH</code>, <code>CONCAT</code> y <code>SUBSTRING</code>, con la semántica esperada:</p>
<pre class="cil"><code>y = LENGTH x ;</code></pre>
<p>Además hay una función STR que computa la representación textual de un valor numérico y devuelve la dirección en memoria:</p>
<pre class="cil"><code>z = STR y ;</code></pre>
<h3 id="operaciones-io">Operaciones IO</h3>
<p>Finalmente, hay 2 instrucciones de entrada-salida, <code>READ</code> que lee de la entrada estándar hasta el siguiente cambio de línea (incluído):</p>
<pre class="cil"><code>x = READ ;</code></pre>
<p>Y <code>PRINT</code> que imprime en la salida estándar, sin incluir el cambio de línea.</p>
<pre class="cil"><code>PRINT z ;</code></pre>
<h2 id="programas-de-ejemplo">Programas de ejemplo</h2>
<p>Veamos algunos programas de ejemplo directamente escritos en CIL antes de pasar a definir cómo haremos la generación de código.</p>
<h3 id="hola-mundo">Hola Mundo</h3>
<p>El &quot;Hola Mundo&quot; en CIL es muy sencillo:</p>
<pre class="cil"><code>.DATA

msg = &quot;Hello World!\n&quot; ;

.CODE

function main {
    LOCAL x ;

    x = LOAD msg ;
    PRINT x ;
    RETURN 0 ;
}</code></pre>
<p>Ahora, este programa si lo fuéramos a generar desde COOL realmente sería un poco más complejo. En COOL sería necesario tener una clase con un método <code>main</code>, y algunos detalles adicionales:</p>
<pre class="cool"><code>class Main: IO {
    msg : string = &quot;Hello World!\n&quot;;

    function main() : IO {
        self.print(self.msg);
    }
}</code></pre>
<p>El programa completo en CIL que representa al programa anterior de COOL sería el siguiente. Hemos tenido cuidado de usar convenios de nombres que luego nos será útil respetar durante la generación de código.</p>
<pre class="cil"><code>.TYPES

type Main {
    attribute Main_msg ;
    method Main_main: f1 ;
}

.DATA

s1 = &quot;Hello World!\n&quot;;

.CODE

function entry {
    LOCAL lmsg ;
    LOCAL instance ;
    LOCAL result ;

    lmsg = LOAD s1 ;
    instance = ALLOCATE Main ;
    SETATTR instance Main_msg lmsg ;

    ARG instance ;
    result = VCALL Main Main_main ;

    RETURN 0 ;
}

function f1 {
    PARAM self ;

    LOCAL lmsg ;

    lmsg = GETATTR self Main_msg ;
    PRINT lmsg ;

    RETURN self ;
}</code></pre>
<p>Podemos ver que el código generado es más ineficiente que el código que se podría concebir manualmente. Este es un resultado necesario del hecho de subir de nivel de abstracción. Un programador humano escribiendo directamente CIL probablemetne pueda generar código más eficiente que nuestro compilador de COOL (al menos hasta que comencemos a aplicar técnicas de optimización de código), pero la ganancia en productividad es tal, que no tiene sentido tal comparación.</p>
<h2 id="generando-código">Generando código</h2>
<p>Veamos entonces algunas ideas sobre cómo generar código concreto de COOL en CIL. Primero nos vamos a concentrar en la generación de expresiones concretas y al final veremos cómo combinarlo todo para generar un programa completo, con sus clases y métodos virtuales.</p>
<h3 id="un-lenguaje-plantilla-para-la-generación-de-código">Un lenguaje plantilla para la generación de código</h3>
<p>Para ejemplificar y documentar nuestras reglas de generación de código vamos a expandir el lenguaje CIL y el lenguaje COOL con una notación informal de &quot;plantilla&quot;. No vamos a ser muy formales con esta notación, ya que no la usaremos nada más que como documentación. La idea básica es que permitiremos algunas expresiones &quot;vagas&quot;, como puntos suspensivos, nombres genéricos, etc., donde nos sea conveniente. Además, no seremos estrictos con escribir todo el código CIL necesario, solamente la parte que corresponda al fragmento de COOL que nos interesa generar, y asumiremos que el lector entiende el contexto. A medida que veamos ejemplos se irá haciendo más claro este &quot;lenguaje&quot;.</p>
<p>Supongamos que tenemos una expresión en COOL de la forma:</p>
<pre class="cool"><code>let x : Integer = 5 in
    x + 1
end</code></pre>
<p>Esta expresión puede ser parte del cuerpo de un método cualquiera, rodeada por cualquier contexto. Asumamos que el método se denomina <code>f</code>, a falta de un nombre mejor. Como no hemos especificado exactamente aquí todo el contexto de la expresión, tendremos que ser vagos con la generación de código. Permitiremos entonces obviar las partes &quot;poco importantes&quot; y concentrarnos solo en la parte que nos interesa. Sin más, presentamos el código CIL:</p>
<pre class="cil-template"><code>function f {
    ...
    LOCAL x ;
    LOCAL &lt;value&gt; ;

    ...
    x = 5 ;
    &lt;value&gt; = x + 1 ;
    ...
}</code></pre>
<p>Aquí hemos tomado por convenio que el valor de la expresión lo guardamos en una variable de nombre <code>&lt;value&gt;</code>, que hemos puesto entre angulares <code>&lt;...&gt;</code> para indicar que este no es el nombre final que quedará en el código CIL real, sino un nombre plantilla que estamos usando ahora a falta de no tener el contexto completo. Es decir, en la generación real de código ese nombre se sustituirá por algo como <code>value_017</code> o cualquier indicador que sea conveniente en ese momento, generado de forma automática.</p>
<p>Por otro lado, supongamos que tenemos una expresión de la forma:</p>
<pre class="cil-template"><code>let x : Integer = 5 in
    x + &lt;expr&gt;
end</code></pre>
<p>En esta expresión también estamos abusando de la notación, con el uso de <code>&lt;expr&gt;</code> para indicar que en COOL aquí va una expresión válida cuya forma exacta no nos interesa. Podemos entonces tomar un convenio como el siguiente:</p>
<pre class="cil-template"><code>function f {
    ...
    &lt;expr.locals&gt;
    LOCAL x ;
    LOCAL &lt;value&gt; ;

    ...
    x = 5 ;
    &lt;expr.code&gt;
    &lt;value&gt; = x + &lt;expr.value&gt; ;
}</code></pre>
<p>El convenio que estamos tomando aquí, es usar <code>&lt;expr.locals&gt;</code> para indicar que se debe rellenar esta parte con todas las inicializaciones de variables locales que sean necesarias para poder computar la expresión <code>&lt;expr&gt;</code>. Además, luego en el cuerpo del método usamos <code>&lt;expr.code&gt;</code> para indicar que se debe rellenar con todo el código generado para la expresión <code>&lt;expr&gt;</code>. Finalmente, asumimos que <code>&lt;expr.value&gt;</code> será reemplazado por el nombre de la variable local que haya sido escogida para almacenar temporalmente el valor de <code>&lt;expr&gt;</code>.</p>
<p>Esperamos que esta notación se vaya haciendo más clara a medida que veamos más ejemplos. Vamos a comenzar entonces con ejemplos concretos:</p>
<h3 id="expresiones-let-in">Expresiones Let-In</h3>
<p>Sea la expresión genérica de COOL <code>let-in</code> con la forma:</p>
<pre class="cool-template"><code>let &lt;var&gt; : &lt;type&gt; = &lt;init&gt; in
    &lt;body&gt;
end</code></pre>
<p>Supongamos que esta expresión ocurre dentro de un método <code>f</code> arbitrario. Podemos entonces definir la generación de código de esta instrucción de la siguiente forma:</p>
<pre class="cil-template"><code>function f {
    ...
    &lt;init.locals&gt;
    LOCAL &lt;var&gt; ;
    &lt;body.locals&gt;
    LOCAL &lt;value&gt; ;

    ...
    &lt;init.code&gt;
    &lt;var&gt; = &lt;init.value&gt; ;
    &lt;body.code&gt;
    &lt;value&gt; = &lt;body.value&gt; ;
}</code></pre>
<p>Puede parecer que no hemos ganado mucho con esta notación, pero en realidad hemos logrado definir para una expresión de tipo <code>let-in</code> arbitraria, exactamente lo que hace falta para su generación de código en CIL. Si interpretamos las expresiones <code>&lt;init.locals&gt;</code> y <code>&lt;body.locals&gt;</code> como, recursivamente, generar las inicializaciones de variables correspondientes, e igualmente <code>&lt;init.code&gt;</code> y <code>&lt;body.code&gt;</code> como, recursivamente, generar los fragmentos de código asociados, podemos ver que esta sintaxis nos permite decir de forma precisa en qué orden hay que recorrer el AST generando qué parte de cada tipo de nodo. No es difícil ver cómo este tipo de plantillas se convierten en respectivos llamados a <em>visitors</em> adecuados para cada parte del código.</p>
<nav>
    <a href="chap6.html" class="navigation previous">Anterior</a>
      <a href="chap8.html" class="navigation next">Siguiente</a>
  </nav>
</body>
</html>
